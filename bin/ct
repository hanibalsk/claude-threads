#!/usr/bin/env bash
#
# ct - claude-threads CLI
#
# Main entry point for the claude-threads framework.
#
# Usage:
#   ct init                          Initialize in current directory
#   ct thread create <name> ...      Create a new thread
#   ct thread list [status]          List threads
#   ct thread start <id>             Start a thread
#   ct thread stop <id>              Stop a thread
#   ct thread status <id>            Show thread status
#   ct thread logs <id>              Show thread logs
#   ct thread delete <id>            Delete a thread
#   ct orchestrator start            Start orchestrator
#   ct orchestrator stop             Stop orchestrator
#   ct orchestrator status           Show orchestrator status
#   ct event publish <type> [data]   Publish an event
#   ct event list                    List recent events
#   ct config show                   Show configuration
#   ct version                       Show version
#

set -euo pipefail

# Find installation directory
CT_ROOT=""
if [[ -d "$HOME/.claude-threads/lib" ]]; then
    CT_ROOT="$HOME/.claude-threads"
elif [[ -d ".claude-threads/lib" ]]; then
    CT_ROOT=".claude-threads"
else
    # Try to find from script location
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    if [[ -d "$SCRIPT_DIR/../lib" ]]; then
        CT_ROOT="$(dirname "$SCRIPT_DIR")"
    fi
fi

if [[ -z "$CT_ROOT" ]]; then
    echo "Error: claude-threads not found. Run 'ct init' first."
    exit 1
fi

# Source libraries
source "$CT_ROOT/lib/utils.sh"
source "$CT_ROOT/lib/log.sh"
source "$CT_ROOT/lib/config.sh"
source "$CT_ROOT/lib/db.sh"
source "$CT_ROOT/lib/git.sh"
source "$CT_ROOT/lib/state.sh"
source "$CT_ROOT/lib/blackboard.sh"
source "$CT_ROOT/lib/template.sh"
source "$CT_ROOT/lib/remote.sh"

# ============================================================
# Configuration
# ============================================================

VERSION=$(cat "$CT_ROOT/VERSION" 2>/dev/null || cat "$CT_ROOT/../VERSION" 2>/dev/null || echo "0.2.0")
DATA_DIR=""
CT_OUTPUT_FORMAT="${CT_OUTPUT_FORMAT:-text}"
CT_VERBOSE="${CT_VERBOSE:-0}"

# Verbose logging helper
verbose() {
    if [[ "$CT_VERBOSE" == "1" ]]; then
        echo "  → $*" >&2
    fi
}

# ============================================================
# Help System
# ============================================================

# Check if help requested
is_help_flag() {
    case "$1" in
        -h|--help) return 0 ;;
        *) return 1 ;;
    esac
}

# Help for main ct command
show_main_help() {
    cat <<EOF
claude-threads v$VERSION - Multi-agent thread orchestration

USAGE
    ct <command> [options]

COMMANDS
    init              Initialize claude-threads in current directory
    thread            Manage threads (create, list, start, stop, status, logs, resume, delete)
    spawn             Create and start a thread in one command
    worktree          Manage git worktrees for isolated development
    orchestrator      Control the orchestrator daemon
    pr                PR shepherd - auto-fix CI and review issues
    event             Publish and list events
    remote            Connect to remote orchestrator
    templates         List and show available templates
    migrate           Database migrations
    webhook           GitHub webhook server
    api               REST API server
    config            Show/edit configuration
    help              Show help for commands
    version           Show version

ALIASES
    t                 Alias for thread
    wt                Alias for worktree
    orch, o           Alias for orchestrator
    e                 Alias for event
    cfg               Alias for config
    wh                Alias for webhook

EXAMPLES
    # Initialize in a project
    ct init

    # Create and start a thread
    ct spawn my-task --template developer.md

    # Create thread with isolated worktree
    ct thread create epic-7a --worktree --worktree-base develop

    # List running threads
    ct thread list running

    # Start orchestrator daemon
    ct orchestrator start

    # Watch a PR for CI/review issues
    ct pr watch 123

    # Connect to remote orchestrator
    ct remote connect localhost:31337 --token my-token

ENVIRONMENT VARIABLES
    CT_DATA_DIR       Data directory (default: .claude-threads)
    CT_OUTPUT_FORMAT  Output format: text or json (default: text)
    CT_VERBOSE        Enable verbose output: 0 or 1 (default: 0)
    CT_API_TOKEN      Authentication token for API/remote
    CT_DEBUG          Enable debug output

MORE HELP
    ct help <command>           Show help for a specific command
    ct help getting-started     Getting started guide
    ct help templates           List available templates

For documentation: https://github.com/hanibalsk/claude-threads
EOF
}

# Help for ct help command
show_help_help() {
    cat <<EOF
ct help - Show help information

USAGE
    ct help [topic]

TOPICS
    (no topic)        Show main help
    getting-started   Quick start guide
    templates         List available templates
    <command>         Help for specific command (thread, spawn, orchestrator, etc.)

EXAMPLES
    ct help
    ct help thread
    ct help getting-started
    ct help templates
EOF
}

# Getting started guide
show_getting_started() {
    cat <<EOF
GETTING STARTED WITH CLAUDE-THREADS

1. INITIALIZE
   ct init

   This creates .claude-threads/ directory with configuration and database.

2. CREATE A THREAD
   ct thread create my-task --mode automatic --template developer.md

   Or use spawn (create + start in one command):
   ct spawn my-task --template developer.md

3. START THE THREAD
   ct thread start <thread-id>

   Automatic threads run in background with 'claude -p'.
   Interactive threads open a Claude session.

4. MONITOR PROGRESS
   ct thread list running     # List running threads
   ct thread status <id>      # Show thread details
   ct thread logs <id>        # View thread output

5. USE WORKTREES FOR ISOLATION
   ct thread create epic-7a --worktree --worktree-base develop

   Each thread gets its own git worktree - no conflicts!

6. RUN ORCHESTRATOR (for multiple threads)
   ct orchestrator start
   ct orchestrator status

7. MULTI-INSTANCE (from another terminal)
   Terminal 1: ct orchestrator start && ct api start
   Terminal 2: ct remote connect localhost:31337
   Terminal 2: ct spawn my-task --template developer.md

NEXT STEPS
   ct help thread       Learn about thread management
   ct help templates    See available templates
   ct help pr           Learn about PR shepherd
EOF
}

# Help for thread command
show_thread_help() {
    cat <<EOF
ct thread - Thread management

USAGE
    ct thread <subcommand> [options]

SUBCOMMANDS
    create <name>     Create a new thread
    list [status]     List threads (optionally filter by status)
    start <id>        Start a thread
    stop <id>         Stop a running thread
    status <id>       Show detailed thread status
    logs <id> [n]     Show last n lines of thread logs (default: 50)
    resume <id>       Resume an interactive thread session
    delete <id>       Delete a thread (--force to delete running)

CREATE OPTIONS
    --mode, -m <mode>         Thread mode: automatic, semi-auto, interactive, sleeping
    --template, -t <file>     Prompt template file
    --context, -c <json>      Thread context as JSON
    --worktree                Create with isolated git worktree
    --worktree-branch <br>    Branch name for worktree
    --worktree-base <br>      Base branch (default: main)

THREAD MODES
    automatic     Runs in background with 'claude -p', fully autonomous
    semi-auto     Automatic with prompts for critical decisions
    interactive   Full interactive mode, every step confirmed
    sleeping      Waiting for trigger (time or event)

THREAD STATUSES
    created       Initial state after creation
    ready         Ready to run
    running       Currently executing
    waiting       Waiting for user input or external event
    sleeping      Paused until trigger
    blocked       Blocked on dependency
    completed     Finished successfully
    failed        Finished with error

EXAMPLES
    ct thread create dev --mode automatic --template developer.md
    ct thread create epic-7a --worktree --worktree-base develop
    ct thread list running
    ct thread start thread-1234567890-abcd
    ct thread status thread-1234567890-abcd
    ct thread logs thread-1234567890-abcd 100
    ct thread delete thread-1234567890-abcd --force

ALIASES
    list → ls
    delete → rm
EOF
}

# Help for spawn command
show_spawn_help() {
    cat <<EOF
ct spawn - Create and start a thread in one command

USAGE
    ct spawn <name> [options]

OPTIONS
    --template, -t <file>     Prompt template file
    --mode, -m <mode>         Thread mode (default: automatic)
    --context, -c <json>      Thread context as JSON
    --worktree, -w            Create with isolated git worktree (DEFAULT for remote)
    --no-worktree             Disable worktree isolation
    --worktree-base <br>      Base branch for worktree (default: main)
    --wait                    Wait for thread completion
    --remote                  Force use of remote API
    --local                   Force use of local database
    --verbose, -v             Show detailed progress output

BEHAVIOR
    - If connected to remote: Uses API automatically with worktree isolation
    - If not connected: Uses local database
    - Remote threads ALWAYS use worktrees by default

EXAMPLES
    # Simple local spawn
    ct spawn my-task --template developer.md

    # Spawn with worktree isolation
    ct spawn epic-7a --template bmad-developer.md -w

    # Spawn and wait for completion
    ct spawn ci-fix --template fixer.md --wait

    # Spawn with verbose output
    ct spawn my-task --template developer.md --verbose

    # Spawn with context
    ct spawn story-42 --template developer.md -c '{"story_id":"42"}'
EOF
}

# Help for orchestrator command
show_orchestrator_help() {
    cat <<EOF
ct orchestrator - Control the orchestrator daemon

USAGE
    ct orchestrator <subcommand>

SUBCOMMANDS
    start       Start orchestrator daemon
    stop        Stop orchestrator daemon
    restart     Restart orchestrator
    status      Show orchestrator status
    tick        Run single iteration (for debugging)

DESCRIPTION
    The orchestrator manages thread lifecycle:
    - Monitors thread states and triggers
    - Processes events from the blackboard
    - Starts sleeping threads when triggers fire
    - Coordinates parallel execution

EXAMPLES
    ct orchestrator start
    ct orchestrator status
    ct orchestrator stop

ALIASES
    orch, o → orchestrator
EOF
}

# Help for remote command
show_remote_help() {
    cat <<EOF
ct remote - Connect to remote orchestrator

USAGE
    ct remote <subcommand> [options]

SUBCOMMANDS
    connect <host:port>   Connect to remote orchestrator
    disconnect            Disconnect from remote
    status                Show connection status
    discover              Auto-discover running orchestrator

CONNECT OPTIONS
    --token, -t TOKEN     Authentication token

ENVIRONMENT VARIABLES
    CT_API_TOKEN          Default authentication token
    CT_API_URL            Default API URL for auto-discovery
    N8N_API_TOKEN         Alternative token variable

EXAMPLES
    # Connect with token
    ct remote connect localhost:31337 --token my-secret-token

    # Connect using environment variable
    export CT_API_TOKEN=my-secret-token
    ct remote connect localhost:31337

    # Auto-discover running orchestrator
    ct remote discover

    # Check connection status
    ct remote status

    # Disconnect
    ct remote disconnect

WORKFLOW
    Terminal 1: ct orchestrator start && ct api start
    Terminal 2: ct remote connect localhost:31337 --token \$TOKEN
    Terminal 2: ct spawn epic-7a --template bmad-developer.md
EOF
}

# Help for worktree command
show_worktree_help() {
    cat <<EOF
ct worktree - Git worktree management

USAGE
    ct worktree <subcommand>

SUBCOMMANDS
    list                  List active worktrees
    status <thread-id>    Show worktree status for a thread
    cleanup [--force]     Cleanup orphaned worktrees

DESCRIPTION
    Worktrees provide isolated git environments for each thread.
    Each thread can work on its own branch without conflicts.

EXAMPLES
    ct worktree list
    ct worktree status thread-1234567890-abcd
    ct worktree cleanup
    ct worktree cleanup --force

ALIASES
    wt → worktree
    list → ls
EOF
}

# Help for pr command
show_pr_help() {
    cat <<EOF
ct pr - PR shepherd for automatic CI/review fixes

USAGE
    ct pr <subcommand> [options]

SUBCOMMANDS
    watch <pr_number>     Start watching a PR
    status [pr_number]    Show PR status (or list all if no number)
    list                  List all watched PRs
    stop <pr_number>      Stop watching a PR
    daemon                Run shepherd as daemon

DESCRIPTION
    The PR shepherd monitors PRs and automatically:
    - Detects CI failures and spawns fix threads
    - Detects review change requests and addresses them
    - Waits for approval and optionally auto-merges

CONFIGURATION (config.yaml)
    pr_shepherd:
      max_fix_attempts: 5       # Max fix attempts before giving up
      ci_poll_interval: 30      # Seconds between CI checks
      idle_poll_interval: 300   # Seconds when idle
      auto_merge: false         # Auto-merge on approval

EXAMPLES
    ct pr watch 123
    ct pr status 123
    ct pr list
    ct pr stop 123
    ct pr daemon
EOF
}

# Help for api command
show_api_help() {
    cat <<EOF
ct api - REST API server for external integrations

USAGE
    ct api <subcommand> [options]

SUBCOMMANDS
    start     Start API server
    stop      Stop API server
    status    Show API status and endpoints

START OPTIONS
    --port PORT           Port to listen on (default: 31337)
    --bind ADDRESS        Address to bind (default: 127.0.0.1)
    --token TOKEN         Authentication token (or use N8N_API_TOKEN env)

ENDPOINTS
    GET  /api/health           Health check
    GET  /api/status           System status
    GET  /api/threads          List threads
    POST /api/threads          Create thread
    GET  /api/threads/:id      Get thread
    POST /api/threads/:id/start  Start thread
    POST /api/threads/:id/stop   Stop thread
    POST /api/events           Publish event

EXAMPLES
    # Start with token
    export N8N_API_TOKEN=my-secret-token
    ct api start

    # Start on custom port
    ct api start --port 8080

    # Check status
    ct api status
EOF
}

# Help for event command
show_event_help() {
    cat <<EOF
ct event - Event management

USAGE
    ct event <subcommand> [options]

SUBCOMMANDS
    publish <type> [data] [source]    Publish an event
    list [limit]                      List recent events (default: 20)

DESCRIPTION
    Events are published to the blackboard and processed by the orchestrator.
    Use events to trigger threads, coordinate between agents, or signal completion.

EXAMPLES
    ct event publish task_complete '{"task_id":"123"}'
    ct event publish ci_failed '{"pr":42,"job":"test"}' github
    ct event list 50

ALIASES
    e → event
    list → ls
EOF
}

# Help for templates command
show_templates_help() {
    cat <<EOF
ct templates - Template management

USAGE
    ct templates <subcommand>

SUBCOMMANDS
    list              List available templates
    show <name>       Show template contents

DESCRIPTION
    Templates are prompt files that define thread behavior.
    They are stored in .claude-threads/templates/

EXAMPLES
    ct templates list
    ct templates show developer.md
    ct templates show prompts/bmad-developer.md
EOF
}

# Help for config command
show_config_help() {
    cat <<EOF
ct config - Configuration management

USAGE
    ct config <subcommand>

SUBCOMMANDS
    show    Show current configuration
    edit    Edit configuration file in \$EDITOR

EXAMPLES
    ct config show
    ct config edit

ALIASES
    cfg → config
EOF
}

# Help for init command
show_init_help() {
    cat <<EOF
ct init - Initialize claude-threads

USAGE
    ct init [directory]

DESCRIPTION
    Creates .claude-threads/ directory with:
    - Database (threads.db)
    - Configuration (config.yaml)
    - Templates directory
    - Scripts for orchestrator, API, etc.

EXAMPLES
    ct init              # Initialize in current directory
    ct init /path/to/project
EOF
}

# Help for webhook command
show_webhook_help() {
    cat <<EOF
ct webhook - GitHub webhook server

USAGE
    ct webhook <subcommand>

SUBCOMMANDS
    start     Start webhook server
    stop      Stop webhook server
    status    Show webhook status

DESCRIPTION
    Receives GitHub webhooks and publishes events to the blackboard.
    Configure webhook URL in GitHub: http://host:31338/webhook

EXAMPLES
    ct webhook start
    ct webhook status
    ct webhook stop

ALIASES
    wh → webhook
EOF
}

# Help for migrate command
show_migrate_help() {
    cat <<EOF
ct migrate - Database migrations

USAGE
    ct migrate [options]

OPTIONS
    --status          Show migration status
    --up              Run pending migrations
    --down            Rollback last migration
    --reset           Reset all migrations (dangerous!)
    --create <name>   Create new migration

EXAMPLES
    ct migrate --status
    ct migrate --up
    ct migrate --down
    ct migrate --create add_priority_column
EOF
}

# Show help for a topic
cmd_help() {
    local topic="${1:-}"

    case "$topic" in
        "") show_main_help ;;
        getting-started|start|quickstart) show_getting_started ;;
        thread|threads|t) show_thread_help ;;
        spawn) show_spawn_help ;;
        orchestrator|orch|o) show_orchestrator_help ;;
        remote) show_remote_help ;;
        worktree|wt) show_worktree_help ;;
        pr) show_pr_help ;;
        api) show_api_help ;;
        event|events|e) show_event_help ;;
        templates|template) show_templates_help ;;
        config|cfg) show_config_help ;;
        init) show_init_help ;;
        webhook|wh) show_webhook_help ;;
        migrate|migration) show_migrate_help ;;
        help) show_help_help ;;
        *)
            echo "No help topic for: $topic"
            echo ""
            echo "Available topics:"
            echo "  getting-started, thread, spawn, orchestrator, remote,"
            echo "  worktree, pr, api, event, templates, config, init,"
            echo "  webhook, migrate"
            exit 1
            ;;
    esac
}

# ============================================================
# Initialization
# ============================================================

init_ct() {
    DATA_DIR="${CT_DATA_DIR:-.claude-threads}"

    if [[ -d "$DATA_DIR" ]]; then
        config_load "$DATA_DIR/config.yaml" 2>/dev/null || true
        db_init "$DATA_DIR" 2>/dev/null || true
        bb_init "$DATA_DIR" 2>/dev/null || true
        remote_init "$DATA_DIR" 2>/dev/null || true
    fi
}

# ============================================================
# Commands: Init
# ============================================================

cmd_init() {
    local target_dir="${1:-$(pwd)}"

    echo "Initializing claude-threads in $target_dir..."

    local data_dir="$target_dir/.claude-threads"

    # Create directories
    mkdir -p "$data_dir"/{lib,sql,templates/prompts,templates/workflows,logs,tmp}

    # Copy files from installation
    if [[ -d "$CT_ROOT/lib" ]]; then
        cp -r "$CT_ROOT/lib/"* "$data_dir/lib/"
    fi
    if [[ -d "$CT_ROOT/sql" ]]; then
        cp -r "$CT_ROOT/sql/"* "$data_dir/sql/"
    fi
    if [[ -d "$CT_ROOT/templates" ]]; then
        cp -r "$CT_ROOT/templates/"* "$data_dir/templates/" 2>/dev/null || true
    fi
    if [[ -f "$CT_ROOT/scripts/orchestrator.sh" ]]; then
        mkdir -p "$data_dir/scripts"
        cp "$CT_ROOT/scripts/"*.sh "$data_dir/scripts/"
        chmod +x "$data_dir/scripts/"*.sh
    fi

    # Create config from example
    if [[ ! -f "$data_dir/config.yaml" ]]; then
        if [[ -f "$CT_ROOT/config.example.yaml" ]]; then
            cp "$CT_ROOT/config.example.yaml" "$data_dir/config.yaml"
        elif [[ -f "$CT_ROOT/../config.example.yaml" ]]; then
            cp "$CT_ROOT/../config.example.yaml" "$data_dir/config.yaml"
        fi
    fi

    # Initialize database
    if [[ -f "$data_dir/sql/schema.sql" ]]; then
        sqlite3 "$data_dir/threads.db" < "$data_dir/sql/schema.sql"
    fi

    # Add to .gitignore
    if [[ -f "$target_dir/.gitignore" ]]; then
        if ! grep -q "^\\.claude-threads/$" "$target_dir/.gitignore" 2>/dev/null; then
            echo "" >> "$target_dir/.gitignore"
            echo "# claude-threads" >> "$target_dir/.gitignore"
            echo ".claude-threads/" >> "$target_dir/.gitignore"
        fi
    fi

    echo "✅ Initialized claude-threads v$VERSION"
    echo ""

    # List available templates
    local template_count=0
    if [[ -d "$data_dir/templates" ]]; then
        template_count=$(find "$data_dir/templates" -name "*.md" -type f 2>/dev/null | wc -l | tr -d ' ')
    fi

    echo "Setup complete:"
    echo "  Data:       $data_dir"
    echo "  Database:   $data_dir/threads.db"
    echo "  Config:     $data_dir/config.yaml"
    echo "  Templates:  $template_count available"
    echo ""
    echo "Quick Start:"
    echo ""
    echo "  1. Create and start a thread:"
    echo "     ct spawn my-task --template developer.md"
    echo ""
    echo "  2. Or use separate steps:"
    echo "     ct thread create my-task --mode automatic"
    echo "     ct thread start <thread-id>"
    echo ""
    echo "  3. Run orchestrator for multiple threads:"
    echo "     ct orchestrator start"
    echo ""
    echo "Claude Code Slash Commands:"
    echo "  /threads        Manage threads"
    echo "  /ct-connect     Connect to remote orchestrator"
    echo "  /ct-spawn       Spawn threads remotely"
    echo ""
    echo "More Help:"
    echo "  ct help                    Main help"
    echo "  ct help getting-started    Tutorial"
    echo "  ct templates list          Available templates"
}

# ============================================================
# Commands: Thread
# ============================================================

cmd_thread() {
    local subcmd="${1:-}"
    shift || true

    # Handle --help at thread level
    if is_help_flag "$subcmd"; then
        show_thread_help
        return 0
    fi

    case "$subcmd" in
        create)
            cmd_thread_create "$@"
            ;;
        list|ls)
            cmd_thread_list "$@"
            ;;
        start)
            cmd_thread_start "$@"
            ;;
        stop)
            cmd_thread_stop "$@"
            ;;
        status)
            cmd_thread_status "$@"
            ;;
        logs)
            cmd_thread_logs "$@"
            ;;
        delete|rm)
            cmd_thread_delete "$@"
            ;;
        resume)
            cmd_thread_resume "$@"
            ;;
        "")
            show_thread_help
            ;;
        *)
            ct_suggest_command "$subcmd" "create" "list" "start" "stop" "status" "logs" "resume" "delete"
            ct_show_help_hint "ct thread"
            exit 1
            ;;
    esac
}

cmd_thread_create() {
    local name=""
    local mode="automatic"
    local template=""
    local workflow=""
    local context="{}"
    local use_worktree=0
    local worktree_branch=""
    local worktree_base="main"

    # Check for help flag first
    for arg in "$@"; do
        if is_help_flag "$arg"; then
            cat <<EOF
ct thread create - Create a new thread

USAGE
    ct thread create <name> [options]

OPTIONS
    --mode, -m <mode>         Thread mode (default: automatic)
                              Values: automatic, semi-auto, interactive, sleeping
    --template, -t <file>     Prompt template file
    --context, -c <json>      Thread context as JSON
    --worktree                Create with isolated git worktree
    --worktree-branch <br>    Branch name for worktree
    --worktree-base <br>      Base branch (default: main)

EXAMPLES
    ct thread create my-task --mode automatic --template developer.md
    ct thread create epic-7a --worktree --worktree-base develop
    ct thread create story-42 -m automatic -t developer.md -c '{"story_id":"42"}'
EOF
            return 0
        fi
    done

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --mode|-m)
                mode="$2"
                shift 2
                ;;
            --template|-t)
                template="$2"
                shift 2
                ;;
            --workflow|-w)
                workflow="$2"
                shift 2
                ;;
            --context|-c)
                context="$2"
                shift 2
                ;;
            --worktree)
                use_worktree=1
                shift
                ;;
            --worktree-branch)
                worktree_branch="$2"
                use_worktree=1
                shift 2
                ;;
            --worktree-base)
                worktree_base="$2"
                use_worktree=1
                shift 2
                ;;
            -*)
                ct_unknown_option "$1" "--mode, -m" "--template, -t" "--context, -c" "--worktree" "--worktree-branch" "--worktree-base"
                ct_show_help_hint "ct thread create"
                exit 1
                ;;
            *)
                name="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$name" ]]; then
        ct_error_with_hint "Thread name is required" "ct thread create <name> --template developer.md"
        ct_show_help_hint "ct thread create"
        exit 1
    fi

    local thread_id

    if [[ $use_worktree -eq 1 ]]; then
        thread_id=$(thread_create_with_worktree "$name" "$mode" "$worktree_branch" "$worktree_base" "$template" "$context")

        local worktree_path
        worktree_path=$(thread_get_worktree "$thread_id")

        echo "Thread created: $thread_id"
        echo "  Name:       $name"
        echo "  Mode:       $mode"
        echo "  Template:   ${template:-none}"
        echo "  Worktree:   $worktree_path"
        echo "  Base:       $worktree_base"
    else
        thread_id=$(thread_create "$name" "$mode" "$template" "$workflow" "$context")

        echo "Thread created: $thread_id"
        echo "  Name:     $name"
        echo "  Mode:     $mode"
        echo "  Template: ${template:-none}"
    fi

    echo ""
    echo "Start with: ct thread start $thread_id"
}

cmd_thread_list() {
    local status=""
    local format="${CT_OUTPUT_FORMAT:-text}"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
ct thread list - List threads

USAGE
    ct thread list [status] [options]

OPTIONS
    --format <format>    Output format: text or json (default: text)

STATUSES
    running, ready, waiting, sleeping, completed, failed, created

EXAMPLES
    ct thread list
    ct thread list running
    ct thread list --format json
    ct thread list completed --format json
EOF
                return 0
                ;;
            --format|-f)
                format="${2:-text}"
                if [[ "$format" != "text" && "$format" != "json" ]]; then
                    ct_error_with_hint "Invalid format: $format" "Valid formats: text, json"
                    exit 1
                fi
                shift 2
                ;;
            -*)
                ct_unknown_option "$1" "--format, -f"
                ct_show_help_hint "ct thread list"
                exit 1
                ;;
            *)
                status="$1"
                shift
                ;;
        esac
    done

    local threads
    if [[ -n "$status" ]]; then
        threads=$(db_threads_by_status "$status")
    else
        threads=$(db_query "SELECT * FROM threads ORDER BY updated_at DESC")
    fi

    local count
    count=$(echo "$threads" | jq 'length')

    # Handle JSON format
    if [[ "$format" == "json" ]]; then
        echo "$threads"
        return 0
    fi

    # Text format (default)
    if [[ $count -eq 0 ]]; then
        echo "No threads found"
        return
    fi

    echo "Threads: $count"
    echo ""
    printf "%-20s %-15s %-12s %-10s %s\n" "ID" "NAME" "MODE" "STATUS" "UPDATED"
    printf "%-20s %-15s %-12s %-10s %s\n" "--------------------" "---------------" "------------" "----------" "-------------------"

    echo "$threads" | jq -r '.[] | [.id[:20], .name[:15], .mode, .status, .updated_at[:19]] | @tsv' | \
        while IFS=$'\t' read -r id name mode st updated; do
            printf "%-20s %-15s %-12s %-10s %s\n" "$id" "$name" "$mode" "$st" "$updated"
        done
}

cmd_thread_start() {
    local thread_id=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
ct thread start - Start a thread

USAGE
    ct thread start <thread-id> [options]

OPTIONS
    --verbose, -v    Show detailed progress output

EXAMPLES
    ct thread start thread-1234567890-abcd
    ct thread start thread-1234567890-abcd --verbose
EOF
                return 0
                ;;
            --verbose|-v)
                CT_VERBOSE=1
                shift
                ;;
            -*)
                ct_unknown_option "$1" "--verbose, -v"
                ct_show_help_hint "ct thread start"
                exit 1
                ;;
            *)
                thread_id="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$thread_id" ]]; then
        ct_error_with_hint "Thread ID required" "ct thread start <thread-id>"
        ct_show_help_hint "ct thread start"
        exit 1
    fi

    # Get thread info
    verbose "Fetching thread info: $thread_id"
    local thread
    thread=$(thread_get "$thread_id")

    if [[ -z "$thread" ]]; then
        ct_error_with_hint "Thread not found: $thread_id" "Run 'ct thread list' to see available threads"
        exit 1
    fi

    local status mode
    status=$(echo "$thread" | jq -r '.status')
    mode=$(echo "$thread" | jq -r '.mode')

    verbose "Thread status: $status, mode: $mode"

    echo "Starting thread: $thread_id (mode=$mode)"

    # Transition to ready if needed
    if [[ "$status" == "created" ]]; then
        verbose "Transitioning from created to ready state"
        thread_ready "$thread_id"
    fi

    # Run thread
    verbose "Launching thread runner..."
    case "$mode" in
        automatic)
            "$DATA_DIR/scripts/thread-runner.sh" --thread-id "$thread_id" --data-dir "$DATA_DIR" --background
            echo "Thread started in background"
            verbose "PID file: $DATA_DIR/tmp/thread-${thread_id}.pid"
            ;;
        semi-auto|interactive)
            "$DATA_DIR/scripts/thread-runner.sh" --thread-id "$thread_id" --data-dir "$DATA_DIR"
            ;;
    esac
}

cmd_thread_stop() {
    local thread_id="$1"

    if [[ -z "$thread_id" ]]; then
        echo "Usage: ct thread stop <thread-id>"
        exit 1
    fi

    # Check for running process
    local pid_file="$DATA_DIR/tmp/thread-${thread_id}.pid"
    if [[ -f "$pid_file" ]]; then
        local pid
        pid=$(cat "$pid_file")
        if kill -0 "$pid" 2>/dev/null; then
            echo "Stopping thread process: $pid"
            kill -TERM "$pid"
            rm -f "$pid_file"
        fi
    fi

    # Update status
    thread_wait "$thread_id" "Stopped by user"
    echo "Thread stopped: $thread_id"
}

cmd_thread_status() {
    local thread_id=""
    local format="${CT_OUTPUT_FORMAT:-text}"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
ct thread status - Show thread status

USAGE
    ct thread status <thread-id> [options]

OPTIONS
    --format <format>    Output format: text or json (default: text)

EXAMPLES
    ct thread status thread-1234567890-abcd
    ct thread status thread-1234567890-abcd --format json
EOF
                return 0
                ;;
            --format|-f)
                format="${2:-text}"
                if [[ "$format" != "text" && "$format" != "json" ]]; then
                    ct_error_with_hint "Invalid format: $format" "Valid formats: text, json"
                    exit 1
                fi
                shift 2
                ;;
            -*)
                ct_unknown_option "$1" "--format, -f"
                ct_show_help_hint "ct thread status"
                exit 1
                ;;
            *)
                thread_id="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$thread_id" ]]; then
        ct_error_with_hint "Thread ID required" "ct thread status <thread-id>"
        ct_show_help_hint "ct thread status"
        exit 1
    fi

    local thread
    thread=$(thread_get "$thread_id")

    if [[ -z "$thread" ]]; then
        ct_error_with_hint "Thread not found: $thread_id" "Run 'ct thread list' to see available threads"
        exit 1
    fi

    # Check if running
    local running_pid=""
    local pid_file="$DATA_DIR/tmp/thread-${thread_id}.pid"
    if [[ -f "$pid_file" ]]; then
        local pid
        pid=$(cat "$pid_file")
        if kill -0 "$pid" 2>/dev/null; then
            running_pid="$pid"
        fi
    fi

    # JSON format
    if [[ "$format" == "json" ]]; then
        if [[ -n "$running_pid" ]]; then
            echo "$thread" | jq --arg pid "$running_pid" '. + {running_pid: $pid}'
        else
            echo "$thread"
        fi
        return 0
    fi

    # Text format (default)
    echo "Thread: $thread_id"
    echo "========================================"
    echo ""
    echo "$thread" | jq -r '
        "Name:       \(.name)",
        "Mode:       \(.mode)",
        "Status:     \(.status)",
        "Phase:      \(.phase // "none")",
        "Template:   \(.template // "none")",
        "Session:    \(.session_id // "none")",
        "Created:    \(.created_at)",
        "Updated:    \(.updated_at)",
        "",
        "Context:",
        (.context | tostring)
    '

    if [[ -n "$running_pid" ]]; then
        echo ""
        echo "Process:    Running (PID $running_pid)"
    fi
}

cmd_thread_logs() {
    local thread_id="$1"
    local lines="${2:-50}"

    if [[ -z "$thread_id" ]]; then
        echo "Usage: ct thread logs <thread-id> [lines]"
        exit 1
    fi

    local log_file="$DATA_DIR/logs/thread-${thread_id}.log"
    local output_file="$DATA_DIR/tmp/thread-${thread_id}-output.txt"

    if [[ -f "$log_file" ]]; then
        echo "=== Thread Log ==="
        tail -n "$lines" "$log_file"
    fi

    if [[ -f "$output_file" ]]; then
        echo ""
        echo "=== Last Output ==="
        tail -n "$lines" "$output_file"
    fi

    if [[ ! -f "$log_file" && ! -f "$output_file" ]]; then
        echo "No logs found for thread: $thread_id"
    fi
}

cmd_thread_resume() {
    local thread_id="$1"

    if [[ -z "$thread_id" ]]; then
        echo "Usage: ct thread resume <thread-id>"
        exit 1
    fi

    local thread
    thread=$(thread_get "$thread_id")

    if [[ -z "$thread" ]]; then
        echo "Thread not found: $thread_id"
        exit 1
    fi

    local session_id
    session_id=$(echo "$thread" | jq -r '.session_id // empty')

    if [[ -z "$session_id" ]]; then
        echo "Thread has no session to resume"
        exit 1
    fi

    echo "Resuming thread session: $session_id"
    claude --resume "$session_id"
}

cmd_thread_delete() {
    local thread_id="$1"
    local force="${2:-}"

    if [[ -z "$thread_id" ]]; then
        echo "Usage: ct thread delete <thread-id> [--force]"
        exit 1
    fi

    local thread
    thread=$(thread_get "$thread_id")

    if [[ -z "$thread" ]]; then
        echo "Thread not found: $thread_id"
        exit 1
    fi

    local status
    status=$(echo "$thread" | jq -r '.status')

    if [[ "$status" == "running" && "$force" != "--force" ]]; then
        echo "Thread is running. Stop it first or use --force"
        exit 1
    fi

    # Stop if running
    if [[ "$status" == "running" ]]; then
        cmd_thread_stop "$thread_id"
    fi

    thread_delete "$thread_id"
    echo "Thread deleted: $thread_id"
}

# ============================================================
# Commands: Orchestrator
# ============================================================

cmd_orchestrator() {
    local subcmd="${1:-}"
    shift || true

    # Handle --help at orchestrator level
    if is_help_flag "$subcmd"; then
        show_orchestrator_help
        return 0
    fi

    local orchestrator_script="$DATA_DIR/scripts/orchestrator.sh"

    if [[ ! -f "$orchestrator_script" ]]; then
        ct_error_with_hint "Orchestrator script not found" "Run 'ct init' first to initialize claude-threads"
        exit 1
    fi

    case "$subcmd" in
        start|stop|restart|status|tick)
            "$orchestrator_script" "$subcmd" --data-dir "$DATA_DIR" "$@"
            ;;
        "")
            show_orchestrator_help
            ;;
        *)
            ct_suggest_command "$subcmd" "start" "stop" "restart" "status" "tick"
            ct_show_help_hint "ct orchestrator"
            exit 1
            ;;
    esac
}

# ============================================================
# Commands: Event
# ============================================================

cmd_event() {
    local subcmd="${1:-}"
    shift || true

    # Handle --help at event level
    if is_help_flag "$subcmd"; then
        show_event_help
        return 0
    fi

    case "$subcmd" in
        publish)
            cmd_event_publish "$@"
            ;;
        list|ls)
            cmd_event_list "$@"
            ;;
        "")
            show_event_help
            ;;
        *)
            ct_suggest_command "$subcmd" "publish" "list"
            ct_show_help_hint "ct event"
            exit 1
            ;;
    esac
}

cmd_event_publish() {
    local type="$1"
    local data="${2:-"{}"}"
    local source="${3:-cli}"

    if [[ -z "$type" ]]; then
        echo "Usage: ct event publish <type> [data] [source]"
        exit 1
    fi

    bb_publish "$type" "$data" "$source"
    echo "Event published: $type"
}

cmd_event_list() {
    local limit="${1:-20}"

    local events
    events=$(bb_history "$limit")

    local count
    count=$(echo "$events" | jq 'length')

    if [[ $count -eq 0 ]]; then
        echo "No events found"
        return
    fi

    echo "Recent Events:"
    echo ""
    printf "%-5s %-20s %-20s %-15s %s\n" "ID" "TIMESTAMP" "TYPE" "SOURCE" "PROCESSED"
    printf "%-5s %-20s %-20s %-15s %s\n" "-----" "--------------------" "--------------------" "---------------" "---------"

    echo "$events" | jq -r '.[] | [.id, .timestamp[:19], .type[:20], .source[:15], (if .processed == 1 then "yes" else "no" end)] | @tsv' | \
        while IFS=$'\t' read -r id ts type source processed; do
            printf "%-5s %-20s %-20s %-15s %s\n" "$id" "$ts" "$type" "$source" "$processed"
        done
}

# ============================================================
# Commands: Webhook
# ============================================================

cmd_webhook() {
    local subcmd="${1:-}"
    shift || true

    # Handle --help at webhook level
    if is_help_flag "$subcmd"; then
        show_webhook_help
        return 0
    fi

    local webhook_script="$DATA_DIR/scripts/webhook-server.sh"

    if [[ ! -f "$webhook_script" ]]; then
        ct_error_with_hint "Webhook server script not found" "Run 'ct init' first to initialize claude-threads"
        exit 1
    fi

    case "$subcmd" in
        start|stop|status)
            "$webhook_script" "$subcmd" --data-dir "$DATA_DIR" "$@"
            ;;
        "")
            show_webhook_help
            ;;
        *)
            ct_suggest_command "$subcmd" "start" "stop" "status"
            ct_show_help_hint "ct webhook"
            exit 1
            ;;
    esac
}

# ============================================================
# Commands: API
# ============================================================

cmd_api() {
    local subcmd="${1:-}"
    shift || true

    # Handle --help at api level
    if is_help_flag "$subcmd"; then
        show_api_help
        return 0
    fi

    local api_script="$DATA_DIR/scripts/api-server.sh"

    if [[ ! -f "$api_script" ]]; then
        ct_error_with_hint "API server script not found" "Run 'ct init' first to initialize claude-threads"
        exit 1
    fi

    case "$subcmd" in
        start|stop|status)
            "$api_script" "$subcmd" --data-dir "$DATA_DIR" "$@"
            ;;
        "")
            show_api_help
            ;;
        *)
            ct_suggest_command "$subcmd" "start" "stop" "status"
            ct_show_help_hint "ct api"
            exit 1
            ;;
    esac
}

# ============================================================
# Commands: PR (Shepherd)
# ============================================================

cmd_pr() {
    local subcmd="${1:-}"
    shift || true

    # Handle --help at pr level
    if is_help_flag "$subcmd"; then
        show_pr_help
        return 0
    fi

    local pr_script="$DATA_DIR/scripts/pr-shepherd.sh"

    if [[ ! -f "$pr_script" ]]; then
        ct_error_with_hint "PR shepherd script not found" "Run 'ct init' first to initialize claude-threads"
        exit 1
    fi

    case "$subcmd" in
        watch|status|list|stop|daemon|tick)
            "$pr_script" "$subcmd" --data-dir "$DATA_DIR" "$@"
            ;;
        "")
            show_pr_help
            ;;
        *)
            ct_suggest_command "$subcmd" "watch" "status" "list" "stop" "daemon"
            ct_show_help_hint "ct pr"
            exit 1
            ;;
    esac
}

# ============================================================
# Commands: Worktree
# ============================================================

cmd_worktree() {
    local subcmd="${1:-}"
    shift || true

    # Handle --help at worktree level
    if is_help_flag "$subcmd"; then
        show_worktree_help
        return 0
    fi

    case "$subcmd" in
        list|ls)
            cmd_worktree_list "$@"
            ;;
        status)
            cmd_worktree_status "$@"
            ;;
        cleanup)
            cmd_worktree_cleanup "$@"
            ;;
        "")
            show_worktree_help
            ;;
        *)
            ct_suggest_command "$subcmd" "list" "status" "cleanup"
            ct_show_help_hint "ct worktree"
            exit 1
            ;;
    esac
}

cmd_worktree_list() {
    echo "Active Worktrees:"
    echo ""

    local worktrees
    worktrees=$(git_worktree_list)

    if [[ -z "$worktrees" ]]; then
        echo "No active worktrees"
        return
    fi

    printf "%-20s %-30s %-10s %s\n" "THREAD ID" "BRANCH" "STATUS" "PATH"
    printf "%-20s %-30s %-10s %s\n" "--------------------" "------------------------------" "----------" "----"

    echo "$worktrees" | while IFS='|' read -r thread_id branch status path; do
        printf "%-20s %-30s %-10s %s\n" "${thread_id:0:20}" "${branch:0:30}" "$status" "$path"
    done
}

cmd_worktree_status() {
    local thread_id="$1"

    if [[ -z "$thread_id" ]]; then
        echo "Usage: ct worktree status <thread-id>"
        exit 1
    fi

    local info
    info=$(git_worktree_info "$thread_id")

    if [[ -z "$info" || "$info" == "{}" ]]; then
        echo "No worktree found for thread: $thread_id"
        exit 1
    fi

    echo "Worktree Status: $thread_id"
    echo "=========================="
    echo ""
    echo "$info" | jq -r '
        "Path:            \(.path)",
        "Branch:          \(.branch)",
        "Status:          \(.status)",
        "Commits ahead:   \(.commits_ahead)",
        "Commits behind:  \(.commits_behind)"
    '
}

cmd_worktree_cleanup() {
    local force="${1:-}"
    local max_age="${2:-7}"

    echo "Cleaning up worktrees..."

    # Cleanup orphaned worktrees
    thread_cleanup_orphaned_worktrees

    # Cleanup old worktrees
    if [[ "$force" == "--force" || "$force" == "-f" ]]; then
        git_cleanup_old_worktrees "$max_age"
    fi

    # Prune git worktrees
    git_worktree_prune

    echo "Cleanup complete"
}

# ============================================================
# Commands: Migrate
# ============================================================

cmd_migrate() {
    local migrate_script="$CT_ROOT/scripts/migrate.sh"

    if [[ ! -f "$migrate_script" ]]; then
        echo "Error: Migration script not found"
        exit 1
    fi

    "$migrate_script" --db "$DATA_DIR/threads.db" "$@"
}

# ============================================================
# Commands: Remote
# ============================================================

cmd_remote() {
    local subcmd="${1:-}"
    shift || true

    # Handle --help at remote level
    if is_help_flag "$subcmd"; then
        show_remote_help
        return 0
    fi

    case "$subcmd" in
        connect)
            cmd_remote_connect "$@"
            ;;
        disconnect)
            cmd_remote_disconnect "$@"
            ;;
        status)
            cmd_remote_status "$@"
            ;;
        discover)
            cmd_remote_discover "$@"
            ;;
        "")
            show_remote_help
            ;;
        *)
            ct_suggest_command "$subcmd" "connect" "disconnect" "status" "discover"
            ct_show_help_hint "ct remote"
            exit 1
            ;;
    esac
}

cmd_remote_connect() {
    local endpoint=""
    local token=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --token|-t)
                token="$2"
                shift 2
                ;;
            -*)
                echo "Unknown option: $1"
                exit 1
                ;;
            *)
                endpoint="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$endpoint" ]]; then
        echo "Usage: ct remote connect <host:port> [--token TOKEN]"
        exit 1
    fi

    # Use provided token or environment variable
    token="${token:-${CT_API_TOKEN:-${N8N_API_TOKEN:-}}}"

    if remote_connect "$endpoint" "$token"; then
        echo "Connected to $endpoint"
        echo ""
        remote_status
    else
        echo "Failed to connect to $endpoint"
        exit 1
    fi
}

cmd_remote_disconnect() {
    remote_disconnect
    echo "Disconnected from remote orchestrator"
}

cmd_remote_status() {
    remote_status
}

cmd_remote_discover() {
    echo "Discovering running orchestrator..."

    if remote_discover "$DATA_DIR"; then
        echo ""
        remote_status
    else
        echo "No running orchestrator found"
        echo ""
        echo "Make sure the API server is running:"
        echo "  ct api start --token <token>"
        exit 1
    fi
}

# ============================================================
# Commands: Spawn
# ============================================================

cmd_spawn() {
    local name=""
    local template=""
    local mode="automatic"
    local context="{}"
    local use_worktree=""  # Empty means: auto (default for remote, optional for local)
    local worktree_base="main"
    local wait_completion=0
    local use_remote=""

    # Check for help flag first
    for arg in "$@"; do
        if is_help_flag "$arg"; then
            show_spawn_help
            return 0
        fi
    done

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --template|-t)
                template="$2"
                shift 2
                ;;
            --mode|-m)
                mode="$2"
                shift 2
                ;;
            --context|-c)
                context="$2"
                shift 2
                ;;
            --worktree|-w)
                use_worktree=1
                shift
                ;;
            --no-worktree)
                use_worktree=0
                shift
                ;;
            --worktree-base)
                worktree_base="$2"
                use_worktree=1
                shift 2
                ;;
            --wait)
                wait_completion=1
                shift
                ;;
            --remote)
                use_remote="1"
                shift
                ;;
            --local)
                use_remote="0"
                shift
                ;;
            --verbose|-v)
                CT_VERBOSE=1
                shift
                ;;
            -*)
                ct_unknown_option "$1" "--template, -t" "--mode, -m" "--context, -c" "--worktree, -w" "--no-worktree" "--worktree-base" "--wait" "--remote" "--local" "--verbose, -v"
                ct_show_help_hint "ct spawn"
                exit 1
                ;;
            *)
                name="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$name" ]]; then
        show_spawn_help
        exit 1
    fi

    verbose "Parsing spawn options"
    verbose "  Name: $name"
    verbose "  Mode: $mode"
    verbose "  Template: ${template:-none}"
    verbose "  Context: $context"

    # Determine whether to use remote or local
    local use_remote_api=0
    if [[ "$use_remote" == "1" ]]; then
        use_remote_api=1
        verbose "Using remote API (forced via --remote)"
    elif [[ "$use_remote" == "0" ]]; then
        use_remote_api=0
        verbose "Using local database (forced via --local)"
    elif remote_is_connected; then
        use_remote_api=1
        verbose "Using remote API (auto-detected connection)"
    else
        verbose "Using local database (no remote connection)"
    fi

    if [[ $use_remote_api -eq 1 ]]; then
        if ! remote_is_connected; then
            echo "Error: Not connected to remote orchestrator"
            echo "Run 'ct remote connect <host:port>' first"
            exit 1
        fi

        # For remote, worktree is DEFAULT (required for isolation)
        # Only disable if explicitly requested with --no-worktree
        if [[ -z "$use_worktree" ]]; then
            use_worktree=1  # Default to enabled for remote
            verbose "Worktree: enabled (default for remote)"
        fi

        echo "Spawning thread via remote API: $name"

        # Build spawn arguments - worktree is handled by remote_spawn (default enabled)
        local spawn_args=("$name")
        [[ -n "$template" ]] && spawn_args+=(--template "$template")
        spawn_args+=(--mode "$mode")
        spawn_args+=(--context "$context")
        spawn_args+=(--worktree-base "$worktree_base")
        [[ $use_worktree -eq 0 ]] && spawn_args+=(--no-worktree)
        [[ $wait_completion -eq 1 ]] && spawn_args+=(--wait)

        verbose "Calling remote_spawn with args: ${spawn_args[*]}"
        remote_spawn "${spawn_args[@]}"
    else
        echo "Spawning thread locally: $name"

        # For local, worktree is optional (default disabled unless specified)
        if [[ -z "$use_worktree" ]]; then
            use_worktree=0  # Default to disabled for local
            verbose "Worktree: disabled (default for local)"
        fi

        # Create thread locally
        verbose "Creating thread in database..."
        local thread_id
        if [[ $use_worktree -eq 1 ]]; then
            verbose "Creating worktree with base branch: $worktree_base"
            thread_id=$(thread_create_with_worktree "$name" "$mode" "" "$worktree_base" "$template" "$context")
            local worktree_path
            worktree_path=$(thread_get_worktree "$thread_id" 2>/dev/null || echo "")
            echo "Created thread: $thread_id"
            [[ -n "$worktree_path" ]] && echo "Worktree: $worktree_path"
        else
            thread_id=$(thread_create "$name" "$mode" "$template" "" "$context")
            echo "Created thread: $thread_id"
        fi

        # Start thread
        verbose "Transitioning thread to ready state..."
        thread_ready "$thread_id"

        verbose "Starting thread runner (mode=$mode)..."
        case "$mode" in
            automatic)
                "$DATA_DIR/scripts/thread-runner.sh" --thread-id "$thread_id" --data-dir "$DATA_DIR" --background
                echo "Thread started in background"
                verbose "Thread runner PID file: $DATA_DIR/tmp/thread-${thread_id}.pid"
                ;;
            semi-auto|interactive)
                "$DATA_DIR/scripts/thread-runner.sh" --thread-id "$thread_id" --data-dir "$DATA_DIR"
                ;;
        esac

        # Wait if requested
        if [[ $wait_completion -eq 1 && "$mode" == "automatic" ]]; then
            echo "Waiting for completion..."
            verbose "Polling thread status every 5 seconds..."
            while true; do
                local status
                status=$(thread_get "$thread_id" | jq -r '.status // empty')
                verbose "Current status: $status"
                case "$status" in
                    completed|failed|cancelled)
                        echo "Thread $thread_id finished: $status"
                        break
                        ;;
                    *)
                        sleep 5
                        ;;
                esac
            done
        fi
    fi
}

# ============================================================
# Commands: Templates
# ============================================================

cmd_templates() {
    local subcmd="${1:-list}"
    shift || true

    # Handle --help at templates level
    if is_help_flag "$subcmd"; then
        show_templates_help
        return 0
    fi

    case "$subcmd" in
        list|ls)
            cmd_templates_list "$@"
            ;;
        show)
            cmd_templates_show "$@"
            ;;
        "")
            cmd_templates_list "$@"
            ;;
        *)
            ct_suggest_command "$subcmd" "list" "show"
            ct_show_help_hint "ct templates"
            exit 1
            ;;
    esac
}

cmd_templates_list() {
    local template_dir="$DATA_DIR/templates"

    echo "Available Templates:"
    echo ""

    if [[ ! -d "$template_dir" ]]; then
        echo "  No templates directory found."
        echo ""
        echo "  Run 'ct init' to initialize with default templates."
        return 0
    fi

    # Find all .md files in templates directory
    local found=0
    while IFS= read -r -d '' template; do
        local relative_path="${template#$template_dir/}"
        local name="${relative_path%.md}"
        printf "  %-30s %s\n" "$relative_path" ""
        found=1
    done < <(find "$template_dir" -name "*.md" -type f -print0 2>/dev/null | sort -z)

    if [[ $found -eq 0 ]]; then
        echo "  No templates found in $template_dir"
        echo ""
        echo "  Create a template file (e.g., developer.md) with a prompt"
        echo "  for your thread to use."
    fi

    echo ""
    echo "Use a template:"
    echo "  ct spawn my-task --template <template-name>"
    echo "  ct thread create my-task --template <template-name>"
}

cmd_templates_show() {
    local name="$1"

    if [[ -z "$name" ]]; then
        ct_error_with_hint "Template name required" "ct templates show <template-name>"
        ct_show_help_hint "ct templates"
        exit 1
    fi

    local template_dir="$DATA_DIR/templates"
    local template_path="$template_dir/$name"

    # Try with and without .md extension
    if [[ ! -f "$template_path" ]]; then
        template_path="$template_dir/${name}.md"
    fi

    if [[ ! -f "$template_path" ]]; then
        ct_error_with_hint "Template not found: $name" "Run 'ct templates list' to see available templates"
        exit 1
    fi

    echo "Template: $name"
    echo "Path: $template_path"
    echo "========================================"
    echo ""
    cat "$template_path"
}

# ============================================================
# Commands: Config
# ============================================================

cmd_config() {
    local subcmd="${1:-show}"

    # Handle --help at config level
    if is_help_flag "$subcmd"; then
        show_config_help
        return 0
    fi

    case "$subcmd" in
        show)
            config_print
            ;;
        edit)
            ${EDITOR:-vi} "$DATA_DIR/config.yaml"
            ;;
        *)
            ct_suggest_command "$subcmd" "show" "edit"
            ct_show_help_hint "ct config"
            exit 1
            ;;
    esac
}

# ============================================================
# Commands: Version
# ============================================================

cmd_version() {
    echo "claude-threads v$VERSION"
}

# ============================================================
# Main
# ============================================================

main() {
    local command="${1:-}"
    shift || true

    # Initialize
    init_ct

    case "$command" in
        init)
            # Handle --help for init
            if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
                show_init_help
                return 0
            fi
            cmd_init "$@"
            ;;
        thread|t)
            cmd_thread "$@"
            ;;
        spawn)
            cmd_spawn "$@"
            ;;
        worktree|wt)
            cmd_worktree "$@"
            ;;
        orchestrator|orch|o)
            cmd_orchestrator "$@"
            ;;
        event|e)
            cmd_event "$@"
            ;;
        remote)
            cmd_remote "$@"
            ;;
        templates|template)
            cmd_templates "$@"
            ;;
        migrate)
            # Handle --help for migrate
            if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
                show_migrate_help
                return 0
            fi
            cmd_migrate "$@"
            ;;
        webhook|wh)
            cmd_webhook "$@"
            ;;
        api)
            cmd_api "$@"
            ;;
        pr)
            cmd_pr "$@"
            ;;
        config|cfg)
            cmd_config "$@"
            ;;
        version|--version|-v)
            cmd_version
            ;;
        help)
            cmd_help "$@"
            ;;
        --help|-h|"")
            show_main_help
            ;;
        *)
            # Try to suggest similar commands
            local suggestions=()
            case "$command" in
                th*|thr*) suggestions+=("thread") ;;
                sp*) suggestions+=("spawn") ;;
                orch*) suggestions+=("orchestrator") ;;
                work*|wor*) suggestions+=("worktree") ;;
                rem*) suggestions+=("remote") ;;
                temp*) suggestions+=("templates") ;;
                ev*) suggestions+=("event") ;;
                web*) suggestions+=("webhook") ;;
                conf*) suggestions+=("config") ;;
                mig*) suggestions+=("migrate") ;;
            esac

            if [[ ${#suggestions[@]} -gt 0 ]]; then
                ct_suggest_command "$command" "${suggestions[@]}"
            else
                echo "Unknown command: $command"
            fi
            ct_show_help_hint "ct"
            exit 1
            ;;
    esac
}

main "$@"
