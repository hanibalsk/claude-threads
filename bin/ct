#!/usr/bin/env bash
#
# ct - claude-threads CLI
#
# Main entry point for the claude-threads framework.
#
# Usage:
#   ct init                          Initialize in current directory
#   ct thread create <name> ...      Create a new thread
#   ct thread list [status]          List threads
#   ct thread start <id>             Start a thread
#   ct thread stop <id>              Stop a thread
#   ct thread status <id>            Show thread status
#   ct thread logs <id>              Show thread logs
#   ct thread delete <id>            Delete a thread
#   ct orchestrator start            Start orchestrator
#   ct orchestrator stop             Stop orchestrator
#   ct orchestrator status           Show orchestrator status
#   ct event publish <type> [data]   Publish an event
#   ct event list                    List recent events
#   ct config show                   Show configuration
#   ct version                       Show version
#

set -euo pipefail

# Find installation directory
CT_ROOT=""
if [[ -d "$HOME/.claude-threads/lib" ]]; then
    CT_ROOT="$HOME/.claude-threads"
elif [[ -d ".claude-threads/lib" ]]; then
    CT_ROOT=".claude-threads"
else
    # Try to find from script location
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    if [[ -d "$SCRIPT_DIR/../lib" ]]; then
        CT_ROOT="$(dirname "$SCRIPT_DIR")"
    fi
fi

if [[ -z "$CT_ROOT" ]]; then
    echo "Error: claude-threads not found. Run 'ct init' first."
    exit 1
fi

# Source libraries
source "$CT_ROOT/lib/utils.sh"
source "$CT_ROOT/lib/log.sh"
source "$CT_ROOT/lib/config.sh"
source "$CT_ROOT/lib/db.sh"
source "$CT_ROOT/lib/git.sh"
source "$CT_ROOT/lib/state.sh"
source "$CT_ROOT/lib/blackboard.sh"
source "$CT_ROOT/lib/template.sh"
source "$CT_ROOT/lib/registry.sh"
source "$CT_ROOT/lib/remote.sh"

# ============================================================
# Configuration
# ============================================================

VERSION=$(cat "$CT_ROOT/VERSION" 2>/dev/null || cat "$CT_ROOT/../VERSION" 2>/dev/null || echo "0.2.0")
DATA_DIR=""
CT_OUTPUT_FORMAT="${CT_OUTPUT_FORMAT:-text}"
CT_VERBOSE="${CT_VERBOSE:-0}"

# Verbose logging helper
verbose() {
    if [[ "$CT_VERBOSE" == "1" ]]; then
        echo "  ‚Üí $*" >&2
    fi
}

# ============================================================
# Help System
# ============================================================

# Check if help requested
is_help_flag() {
    case "$1" in
        -h|--help) return 0 ;;
        *) return 1 ;;
    esac
}

# Help for main ct command
show_main_help() {
    cat <<EOF
claude-threads v$VERSION - Multi-agent thread orchestration

USAGE
    ct <command> [options]

COMMANDS
    init              Initialize claude-threads in current directory
    thread            Manage threads (create, list, start, stop, status, logs, resume, delete)
    spawn             Create and start a thread in one command
    worktree          Manage git worktrees for isolated development
    orchestrator      Control the orchestrator daemon
    merge             Merge completed thread work (direct, PR, or manual)
    pr                PR shepherd - auto-fix CI and review issues
    session           Session persistence and coordination
    memory            Cross-session memory management
    event             Publish and list events
    remote            Connect to remote orchestrator
    instances         Manage running instances (port registry)
    templates         List and show available templates
    migrate           Database migrations
    webhook           GitHub webhook server
    api               REST API server
    config            Show/edit configuration
    help              Show help for commands
    version           Show version

ALIASES
    t                 Alias for thread
    wt                Alias for worktree
    orch, o           Alias for orchestrator
    ses               Alias for session
    mem               Alias for memory
    e                 Alias for event
    inst, i           Alias for instances
    cfg               Alias for config
    wh                Alias for webhook

EXAMPLES
    # Initialize in a project
    ct init

    # Create and start a thread
    ct spawn my-task --template developer.md

    # Create thread with isolated worktree
    ct thread create epic-7a --worktree --worktree-base develop

    # List running threads
    ct thread list running

    # Start orchestrator daemon
    ct orchestrator start

    # Watch a PR for CI/review issues
    ct pr watch 123

    # Connect to remote orchestrator
    ct remote connect localhost:31337 --token my-token

ENVIRONMENT VARIABLES
    CT_DATA_DIR       Data directory (default: .claude-threads)
    CT_OUTPUT_FORMAT  Output format: text or json (default: text)
    CT_VERBOSE        Enable verbose output: 0 or 1 (default: 0)
    CT_API_TOKEN      Authentication token for API/remote
    CT_DEBUG          Enable debug output

MORE HELP
    ct help <command>           Show help for a specific command
    ct help getting-started     Getting started guide
    ct help templates           List available templates

For documentation: https://github.com/hanibalsk/claude-threads
EOF
}

# Help for ct help command
show_help_help() {
    cat <<EOF
ct help - Show help information

USAGE
    ct help [topic]

TOPICS
    (no topic)        Show main help
    getting-started   Quick start guide
    templates         List available templates
    <command>         Help for specific command (thread, spawn, orchestrator, etc.)

EXAMPLES
    ct help
    ct help thread
    ct help getting-started
    ct help templates
EOF
}

# Getting started guide
show_getting_started() {
    cat <<EOF
GETTING STARTED WITH CLAUDE-THREADS

1. INITIALIZE
   ct init

   This creates .claude-threads/ directory with configuration and database.

2. CREATE A THREAD
   ct thread create my-task --mode automatic --template developer.md

   Or use spawn (create + start in one command):
   ct spawn my-task --template developer.md

3. START THE THREAD
   ct thread start <thread-id>

   Automatic threads run in background with 'claude -p'.
   Interactive threads open a Claude session.

4. MONITOR PROGRESS
   ct thread list running     # List running threads
   ct thread status <id>      # Show thread details
   ct thread logs <id>        # View thread output

5. USE WORKTREES FOR ISOLATION
   ct thread create epic-7a --worktree --worktree-base develop

   Each thread gets its own git worktree - no conflicts!

6. RUN ORCHESTRATOR (for multiple threads)
   ct orchestrator start
   ct orchestrator status

7. MULTI-INSTANCE (from another terminal)
   Terminal 1: ct orchestrator start && ct api start
   Terminal 2: ct remote connect localhost:31337
   Terminal 2: ct spawn my-task --template developer.md

NEXT STEPS
   ct help thread       Learn about thread management
   ct help templates    See available templates
   ct help pr           Learn about PR shepherd
EOF
}

# Help for thread command
show_thread_help() {
    cat <<EOF
ct thread - Thread management

USAGE
    ct thread <subcommand> [options]

SUBCOMMANDS
    create <name>     Create a new thread
    list [status]     List threads (optionally filter by status)
    start <id>        Start a thread
    stop <id>         Stop a running thread
    status <id>       Show detailed thread status
    logs <id> [n]     Show last n lines of thread logs (default: 50)
    resume <id>       Resume an interactive thread session
    delete <id>       Delete a thread (--force to delete running)
    send <id> <msg>   Send a message to a running thread
    inbox <id>        View messages in thread's inbox

CREATE OPTIONS
    --mode, -m <mode>         Thread mode: automatic, semi-auto, interactive, sleeping
    --template, -t <file>     Prompt template file
    --context, -c <json>      Thread context as JSON
    --worktree                Create with isolated git worktree
    --worktree-branch <br>    Branch name for worktree
    --worktree-base <br>      Base branch (default: main)

THREAD MODES
    automatic     Runs in background with 'claude -p', fully autonomous
    semi-auto     Automatic with prompts for critical decisions
    interactive   Full interactive mode, every step confirmed
    sleeping      Waiting for trigger (time or event)

THREAD STATUSES
    created       Initial state after creation
    ready         Ready to run
    running       Currently executing
    waiting       Waiting for user input or external event
    sleeping      Paused until trigger
    blocked       Blocked on dependency
    completed     Finished successfully
    failed        Finished with error

EXAMPLES
    ct thread create dev --mode automatic --template developer.md
    ct thread create epic-7a --worktree --worktree-base develop
    ct thread list running
    ct thread start thread-1234567890-abcd
    ct thread status thread-1234567890-abcd
    ct thread logs thread-1234567890-abcd 100
    ct thread delete thread-1234567890-abcd --force

COMMUNICATION
    ct thread send <id> "message"           Send instruction to thread
    ct thread send <id> "task" --type TASK  Assign a new task
    ct thread inbox <id>                    Check thread's message queue

ALIASES
    list ‚Üí ls
    delete ‚Üí rm
EOF
}

# Help for spawn command
show_spawn_help() {
    cat <<EOF
ct spawn - Create and start a thread in one command

USAGE
    ct spawn <name> [options]

OPTIONS
    --template, -t <file>     Prompt template file
    --mode, -m <mode>         Thread mode (default: automatic)
    --context, -c <json>      Thread context as JSON
    --worktree, -w            Create with isolated git worktree (DEFAULT for remote)
    --no-worktree             Disable worktree isolation
    --worktree-base <br>      Base branch for worktree (default: main)
    --wait                    Wait for thread completion
    --remote                  Force use of remote API
    --local                   Force use of local database
    --verbose, -v             Show detailed progress output

BEHAVIOR
    - If connected to remote: Uses API automatically with worktree isolation
    - If not connected: Uses local database
    - Remote threads ALWAYS use worktrees by default

EXAMPLES
    # Simple local spawn
    ct spawn my-task --template developer.md

    # Spawn with worktree isolation
    ct spawn epic-7a --template bmad-developer.md -w

    # Spawn and wait for completion
    ct spawn ci-fix --template fixer.md --wait

    # Spawn with verbose output
    ct spawn my-task --template developer.md --verbose

    # Spawn with context
    ct spawn story-42 --template developer.md -c '{"story_id":"42"}'
EOF
}

# Help for orchestrator command
show_orchestrator_help() {
    cat <<EOF
ct orchestrator - Control the orchestrator daemon

USAGE
    ct orchestrator <subcommand>

SUBCOMMANDS
    start       Start orchestrator daemon
    stop        Stop orchestrator daemon
    restart     Restart orchestrator
    status      Show orchestrator status
    tick        Run single iteration (for debugging)

DESCRIPTION
    The orchestrator manages thread lifecycle:
    - Monitors thread states and triggers
    - Processes events from the blackboard
    - Starts sleeping threads when triggers fire
    - Coordinates parallel execution

EXAMPLES
    ct orchestrator start
    ct orchestrator status
    ct orchestrator stop

ALIASES
    orch, o ‚Üí orchestrator
EOF
}

# Help for remote command
show_remote_help() {
    cat <<EOF
ct remote - Connect to remote orchestrator

USAGE
    ct remote <subcommand> [options]

SUBCOMMANDS
    connect <host:port>   Connect to remote orchestrator
    disconnect            Disconnect from remote
    status                Show connection status
    discover              Auto-discover running orchestrator

CONNECT OPTIONS
    --token, -t TOKEN     Authentication token

ENVIRONMENT VARIABLES
    CT_API_TOKEN          Default authentication token
    CT_API_URL            Default API URL for auto-discovery
    N8N_API_TOKEN         Alternative token variable

EXAMPLES
    # Connect with token
    ct remote connect localhost:31337 --token my-secret-token

    # Connect using environment variable
    export CT_API_TOKEN=my-secret-token
    ct remote connect localhost:31337

    # Auto-discover running orchestrator
    ct remote discover

    # Check connection status
    ct remote status

    # Disconnect
    ct remote disconnect

WORKFLOW
    Terminal 1: ct orchestrator start && ct api start
    Terminal 2: ct remote connect localhost:31337 --token \$TOKEN
    Terminal 2: ct spawn epic-7a --template bmad-developer.md
EOF
}

# Help for worktree command
show_worktree_help() {
    cat <<EOF
ct worktree - Git worktree management

USAGE
    ct worktree <subcommand>

SUBCOMMANDS
    list                  List active worktrees
    status <thread-id>    Show worktree status for a thread
    cleanup [--force]     Cleanup orphaned worktrees

PR BASE WORKTREE (Memory Optimization)
    base-create <pr> <branch> [target]   Create PR base worktree
    base-update <pr>                     Update PR base with remote
    base-status <pr>                     Show base worktree and forks
    base-remove <pr> [--force]           Remove base and all forks

    fork <pr> <id> <branch> [purpose]    Fork from PR base worktree
    merge-back <fork-id> [--no-push]     Merge fork back to base
    remove-fork <fork-id> [--force]      Remove a fork worktree
    list-forks <pr>                      List forks for a PR

MAINTENANCE
    reconcile [--fix]     Sync database with filesystem state

FORK PURPOSE OPTIONS
    conflict_resolution   For resolving merge conflicts
    comment_handler       For handling review comments
    ci_fix               For fixing CI issues
    general              General purpose (default)

DESCRIPTION
    Worktrees provide isolated git environments for each thread.
    Each thread can work on its own branch without conflicts.

    PR Base Worktree Pattern (Memory Optimization):
    - One base worktree per PR tracks the PR branch
    - Sub-agents fork from base (shares git objects)
    - Forks are merged back and removed after use
    - Reduces disk/memory usage for parallel agents
    - Database tracks all operations for auditing

EXAMPLES
    ct worktree list
    ct worktree status thread-1234567890-abcd
    ct worktree cleanup --force

    # PR base worktree workflow
    ct worktree base-create 123 feature/my-branch main
    ct worktree fork 123 conflict-resolver fix/conflict conflict_resolution
    ct worktree merge-back conflict-resolver
    ct worktree remove-fork conflict-resolver
    ct worktree base-status 123

    # Fix database/filesystem inconsistencies
    ct worktree reconcile --fix

ALIASES
    wt ‚Üí worktree
    list ‚Üí ls
EOF
}

# Help for pr command
show_pr_help() {
    cat <<EOF
ct pr - PR lifecycle management with multi-agent coordination

USAGE
    ct pr <subcommand> [options]

SUBCOMMANDS
    watch <pr_number>     Start watching a PR with full lifecycle management
    status [pr_number]    Show PR lifecycle status
    comments <pr_number>  Show review comments status
    conflicts <pr_number> Show merge conflict status
    list                  List all watched PRs
    stop <pr_number>      Stop watching a PR
    daemon                Run shepherd as daemon

WATCH OPTIONS
    --auto-merge          Auto-merge when all criteria are met
    --interactive         Confirm actions before executing
    --poll-interval <sec> Seconds between status polls (default: 30)

DESCRIPTION
    The PR lifecycle manager monitors PRs and:
    - Polls PR status via git (not webhooks)
    - Spawns merge conflict resolver agents
    - Spawns review comment handler agents
    - Ensures all comments are responded AND resolved
    - Auto-merges when all criteria met (if enabled)

PR COMPLETION CRITERIA
    All must be true:
    - CI passing (all checks green)
    - No merge conflicts
    - All review comments responded
    - All review comments resolved
    - Required approvals received

CONFIGURATION (config.yaml)
    pr_lifecycle:
      poll_interval: 30           # Seconds between polls
      default_auto_merge: false   # Auto-merge default
      default_interactive: false  # Interactive mode default
      max_conflict_retries: 3     # Conflict resolution attempts
      max_comment_handlers: 5     # Parallel comment handlers

EXAMPLES
    ct pr watch 123 --auto-merge
    ct pr watch 123 --interactive --poll-interval 60
    ct pr status 123
    ct pr comments 123
    ct pr list
EOF
}

# Help for control command
show_control_help() {
    cat <<EOF
ct control - Master orchestrator control for multi-agent coordination

USAGE
    ct control <subcommand> [options]

SUBCOMMANDS
    start     Start orchestrator control thread
    status    Show control thread status
    stop      Stop control thread

START OPTIONS
    --auto-merge          Enable auto-merge for watched PRs
    --interactive         Confirm actions before executing

DESCRIPTION
    The control thread manages the entire orchestrator:
    - Starts/stops the orchestrator daemon
    - Spawns PR shepherd agents when needed
    - Handles escalations from sub-agents
    - Monitors system health

EXAMPLES
    ct control start
    ct control start --auto-merge
    ct control start --interactive
    ct control status
    ct control stop
EOF
}

# Help for api command
show_api_help() {
    cat <<EOF
ct api - REST API server for external integrations

USAGE
    ct api <subcommand> [options]

SUBCOMMANDS
    start     Start API server
    stop      Stop API server
    status    Show API status and endpoints

START OPTIONS
    --port PORT           Port to listen on (default: 31337)
    --bind ADDRESS        Address to bind (default: 127.0.0.1)
    --token TOKEN         Authentication token (or use N8N_API_TOKEN env)

ENDPOINTS
    GET  /api/health           Health check
    GET  /api/status           System status
    GET  /api/threads          List threads
    POST /api/threads          Create thread
    GET  /api/threads/:id      Get thread
    POST /api/threads/:id/start  Start thread
    POST /api/threads/:id/stop   Stop thread
    POST /api/events           Publish event

EXAMPLES
    # Start with token
    export N8N_API_TOKEN=my-secret-token
    ct api start

    # Start on custom port
    ct api start --port 8080

    # Check status
    ct api status
EOF
}

# Help for event command
show_event_help() {
    cat <<EOF
ct event - Event management

USAGE
    ct event <subcommand> [options]

SUBCOMMANDS
    publish <type> [data] [source]    Publish an event
    list [limit]                      List recent events (default: 20)

DESCRIPTION
    Events are published to the blackboard and processed by the orchestrator.
    Use events to trigger threads, coordinate between agents, or signal completion.

EXAMPLES
    ct event publish task_complete '{"task_id":"123"}'
    ct event publish ci_failed '{"pr":42,"job":"test"}' github
    ct event list 50

ALIASES
    e ‚Üí event
    list ‚Üí ls
EOF
}

# Help for templates command
show_templates_help() {
    cat <<EOF
ct templates - Template management

USAGE
    ct templates <subcommand>

SUBCOMMANDS
    list              List available templates
    show <name>       Show template contents

DESCRIPTION
    Templates are prompt files that define thread behavior.
    They are stored in .claude-threads/templates/

EXAMPLES
    ct templates list
    ct templates show developer.md
    ct templates show prompts/bmad-developer.md
EOF
}

# Help for config command
show_config_help() {
    cat <<EOF
ct config - Configuration management

USAGE
    ct config <subcommand>

SUBCOMMANDS
    show    Show current configuration
    edit    Edit configuration file in \$EDITOR

EXAMPLES
    ct config show
    ct config edit

ALIASES
    cfg ‚Üí config
EOF
}

# Help for init command
show_init_help() {
    cat <<EOF
ct init - Initialize claude-threads

USAGE
    ct init [directory]

DESCRIPTION
    Creates .claude-threads/ directory with:
    - Database (threads.db)
    - Configuration (config.yaml)
    - Templates directory
    - Scripts for orchestrator, API, etc.

EXAMPLES
    ct init              # Initialize in current directory
    ct init /path/to/project
EOF
}

# Help for webhook command
show_webhook_help() {
    cat <<EOF
ct webhook - GitHub webhook server

USAGE
    ct webhook <subcommand>

SUBCOMMANDS
    start     Start webhook server
    stop      Stop webhook server
    status    Show webhook status

DESCRIPTION
    Receives GitHub webhooks and publishes events to the blackboard.
    Configure webhook URL in GitHub: http://host:31338/webhook

EXAMPLES
    ct webhook start
    ct webhook status
    ct webhook stop

ALIASES
    wh ‚Üí webhook
EOF
}

# Help for migrate command
show_migrate_help() {
    cat <<EOF
ct migrate - Database migrations

USAGE
    ct migrate [options]

OPTIONS
    --status          Show migration status
    --up              Run pending migrations
    --down            Rollback last migration
    --reset           Reset all migrations (dangerous!)
    --create <name>   Create new migration

EXAMPLES
    ct migrate --status
    ct migrate --up
    ct migrate --down
    ct migrate --create add_priority_column
EOF
}

# Help for session command
show_session_help() {
    cat <<EOF
ct session - Session management for context persistence

USAGE
    ct session <subcommand> [options]

SUBCOMMANDS
    start <thread-id>      Start a new session for a thread
    resume <session-id>    Resume a previous session
    fork <thread-id>       Fork current session (create branch)
    history <thread-id>    Show session history for a thread
    checkpoint             Create or view checkpoints
    coordinate             Multi-agent coordination

CHECKPOINT OPTIONS
    --thread-id <id>       Thread to checkpoint
    --type <type>          Type: periodic, before_compaction, manual, coordination
    --latest               Show latest checkpoint
    --state-summary <text> Summary of current state
    --pending-tasks <json> JSON array of pending tasks

COORDINATE OPTIONS
    --register             Register agent with orchestrator
    --orchestrator-session <id>  Orchestrator session ID
    --agent-thread <id>    Agent thread ID
    --update-context       Update shared context
    --shared-context <json>  JSON context to share
    --due-checkpoints      List agents needing checkpoint

DESCRIPTION
    Session management enables:
    - Context persistence across restarts
    - Session forking for exploring alternatives
    - Periodic checkpoints for long-running agents
    - Multi-agent coordination with shared context

EXAMPLES
    ct session start thread-123
    ct session resume ses_1234567890_abcd
    ct session fork thread-123
    ct session history thread-123
    ct session checkpoint --thread-id thread-123 --type periodic
    ct session checkpoint --latest --thread-id thread-123
    ct session coordinate --register --orchestrator-session ses_abc --agent-thread thread-123
    ct session coordinate --due-checkpoints
EOF
}

# Help for memory command
show_memory_help() {
    cat <<EOF
ct memory - Cross-session memory management

USAGE
    ct memory <subcommand> [options]

SUBCOMMANDS
    set           Store a memory entry
    get           Retrieve a memory entry
    list          List memories
    delete        Delete a memory entry
    summary       Get memory summary for context injection
    cleanup       Remove expired memories

SET OPTIONS
    --thread-id <id>       Thread ID (omit for global memory)
    --category <cat>       Category: project, decision, error, pattern, preference, context
    --key <key>            Memory key
    --value <value>        Memory value
    --importance <1-10>    Importance level (default: 5)
    --expires <datetime>   Optional expiration

GET OPTIONS
    --thread-id <id>       Thread ID (omit for global memory)
    --category <cat>       Category
    --key <key>            Memory key

LIST OPTIONS
    --thread-id <id>       Filter by thread (omit for all including global)
    --category <cat>       Filter by category

DESCRIPTION
    Memory provides persistent storage that survives sessions:
    - Store important decisions and context
    - Record error patterns and fixes
    - Maintain project knowledge across agents
    - Inject relevant memories into context

EXAMPLES
    # Store a project decision
    ct memory set --category decision --key "auth_strategy" --value "JWT tokens" --importance 8

    # Store thread-specific context
    ct memory set --thread-id thread-123 --category context --key "current_file" --value "src/main.ts"

    # Get a memory
    ct memory get --category decision --key "auth_strategy"

    # List all memories for a thread
    ct memory list --thread-id thread-123

    # Get memory summary for context injection
    ct memory summary --thread-id thread-123

    # Cleanup expired memories
    ct memory cleanup
EOF
}

# Show help for a topic
cmd_help() {
    local topic="${1:-}"

    case "$topic" in
        "") show_main_help ;;
        getting-started|start|quickstart) show_getting_started ;;
        thread|threads|t) show_thread_help ;;
        spawn) show_spawn_help ;;
        orchestrator|orch|o) show_orchestrator_help ;;
        remote) show_remote_help ;;
        worktree|wt) show_worktree_help ;;
        pr) show_pr_help ;;
        control) show_control_help ;;
        session|ses) show_session_help ;;
        memory|mem) show_memory_help ;;
        api) show_api_help ;;
        event|events|e) show_event_help ;;
        templates|template) show_templates_help ;;
        config|cfg) show_config_help ;;
        init) show_init_help ;;
        webhook|wh) show_webhook_help ;;
        migrate|migration) show_migrate_help ;;
        help) show_help_help ;;
        *)
            echo "No help topic for: $topic"
            echo ""
            echo "Available topics:"
            echo "  getting-started, thread, spawn, orchestrator, remote,"
            echo "  worktree, pr, session, memory, api, event, templates,"
            echo "  config, init, webhook, migrate"
            exit 1
            ;;
    esac
}

# ============================================================
# Initialization
# ============================================================

init_ct() {
    DATA_DIR="${CT_DATA_DIR:-.claude-threads}"

    if [[ -d "$DATA_DIR" ]]; then
        config_load "$DATA_DIR/config.yaml" 2>/dev/null || true
        db_init "$DATA_DIR" 2>/dev/null || true
        bb_init "$DATA_DIR" 2>/dev/null || true
        remote_init "$DATA_DIR" 2>/dev/null || true
    fi
}

# ============================================================
# Commands: Init
# ============================================================

cmd_init() {
    local target_dir="${1:-$(pwd)}"

    echo "Initializing claude-threads in $target_dir..."

    local data_dir="$target_dir/.claude-threads"

    # Create directories
    mkdir -p "$data_dir"/{lib,sql,templates/prompts,templates/workflows,logs,tmp}

    # Copy files from installation
    if [[ -d "$CT_ROOT/lib" ]]; then
        cp -r "$CT_ROOT/lib/"* "$data_dir/lib/"
    fi
    if [[ -d "$CT_ROOT/sql" ]]; then
        cp -r "$CT_ROOT/sql/"* "$data_dir/sql/"
    fi
    if [[ -d "$CT_ROOT/templates" ]]; then
        cp -r "$CT_ROOT/templates/"* "$data_dir/templates/" 2>/dev/null || true
    fi
    if [[ -f "$CT_ROOT/scripts/orchestrator.sh" ]]; then
        mkdir -p "$data_dir/scripts"
        cp "$CT_ROOT/scripts/"*.sh "$data_dir/scripts/"
        chmod +x "$data_dir/scripts/"*.sh
    fi

    # Create config from example
    if [[ ! -f "$data_dir/config.yaml" ]]; then
        if [[ -f "$CT_ROOT/config.example.yaml" ]]; then
            cp "$CT_ROOT/config.example.yaml" "$data_dir/config.yaml"
        elif [[ -f "$CT_ROOT/../config.example.yaml" ]]; then
            cp "$CT_ROOT/../config.example.yaml" "$data_dir/config.yaml"
        fi
    fi

    # Initialize database
    if [[ -f "$data_dir/sql/schema.sql" ]]; then
        sqlite3 "$data_dir/threads.db" < "$data_dir/sql/schema.sql"
    fi

    # Add to .gitignore
    if [[ -f "$target_dir/.gitignore" ]]; then
        if ! grep -q "^\\.claude-threads/$" "$target_dir/.gitignore" 2>/dev/null; then
            echo "" >> "$target_dir/.gitignore"
            echo "# claude-threads" >> "$target_dir/.gitignore"
            echo ".claude-threads/" >> "$target_dir/.gitignore"
        fi
    fi

    echo "‚úÖ Initialized claude-threads v$VERSION"
    echo ""

    # List available templates
    local template_count=0
    if [[ -d "$data_dir/templates" ]]; then
        template_count=$(find "$data_dir/templates" -name "*.md" -type f 2>/dev/null | wc -l | tr -d ' ')
    fi

    echo "Setup complete:"
    echo "  Data:       $data_dir"
    echo "  Database:   $data_dir/threads.db"
    echo "  Config:     $data_dir/config.yaml"
    echo "  Templates:  $template_count available"
    echo ""
    echo "Quick Start:"
    echo ""
    echo "  1. Create and start a thread:"
    echo "     ct spawn my-task --template developer.md"
    echo ""
    echo "  2. Or use separate steps:"
    echo "     ct thread create my-task --mode automatic"
    echo "     ct thread start <thread-id>"
    echo ""
    echo "  3. Run orchestrator for multiple threads:"
    echo "     ct orchestrator start"
    echo ""
    echo "Claude Code Slash Commands:"
    echo "  /threads        Manage threads"
    echo "  /ct-connect     Connect to remote orchestrator"
    echo "  /ct-spawn       Spawn threads remotely"
    echo ""
    echo "More Help:"
    echo "  ct help                    Main help"
    echo "  ct help getting-started    Tutorial"
    echo "  ct templates list          Available templates"
}

# ============================================================
# Commands: Thread
# ============================================================

cmd_thread() {
    local subcmd="${1:-}"
    shift || true

    # Handle --help at thread level
    if is_help_flag "$subcmd"; then
        show_thread_help
        return 0
    fi

    case "$subcmd" in
        create)
            cmd_thread_create "$@"
            ;;
        list|ls)
            cmd_thread_list "$@"
            ;;
        start)
            cmd_thread_start "$@"
            ;;
        stop)
            cmd_thread_stop "$@"
            ;;
        status)
            cmd_thread_status "$@"
            ;;
        logs)
            cmd_thread_logs "$@"
            ;;
        delete|rm)
            cmd_thread_delete "$@"
            ;;
        resume)
            cmd_thread_resume "$@"
            ;;
        send)
            cmd_thread_send "$@"
            ;;
        inbox)
            cmd_thread_inbox "$@"
            ;;
        "")
            show_thread_help
            ;;
        *)
            ct_suggest_command "$subcmd" "create" "list" "start" "stop" "status" "logs" "resume" "delete" "send" "inbox"
            ct_show_help_hint "ct thread"
            exit 1
            ;;
    esac
}

cmd_thread_create() {
    local name=""
    local mode="automatic"
    local template=""
    local workflow=""
    local context="{}"
    local use_worktree=0
    local worktree_branch=""
    local worktree_base="main"

    # Check for help flag first
    for arg in "$@"; do
        if is_help_flag "$arg"; then
            cat <<EOF
ct thread create - Create a new thread

USAGE
    ct thread create <name> [options]

OPTIONS
    --mode, -m <mode>         Thread mode (default: automatic)
                              Values: automatic, semi-auto, interactive, sleeping
    --template, -t <file>     Prompt template file
    --context, -c <json>      Thread context as JSON
    --worktree                Create with isolated git worktree
    --worktree-branch <br>    Branch name for worktree
    --worktree-base <br>      Base branch (default: main)

EXAMPLES
    ct thread create my-task --mode automatic --template developer.md
    ct thread create epic-7a --worktree --worktree-base develop
    ct thread create story-42 -m automatic -t developer.md -c '{"story_id":"42"}'
EOF
            return 0
        fi
    done

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --mode|-m)
                mode="$2"
                shift 2
                ;;
            --template|-t)
                template="$2"
                shift 2
                ;;
            --workflow|-w)
                workflow="$2"
                shift 2
                ;;
            --context|-c)
                context="$2"
                shift 2
                ;;
            --worktree)
                use_worktree=1
                shift
                ;;
            --worktree-branch)
                worktree_branch="$2"
                use_worktree=1
                shift 2
                ;;
            --worktree-base)
                worktree_base="$2"
                use_worktree=1
                shift 2
                ;;
            -*)
                ct_unknown_option "$1" "--mode, -m" "--template, -t" "--context, -c" "--worktree" "--worktree-branch" "--worktree-base"
                ct_show_help_hint "ct thread create"
                exit 1
                ;;
            *)
                name="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$name" ]]; then
        ct_error_with_hint "Thread name is required" "ct thread create <name> --template developer.md"
        ct_show_help_hint "ct thread create"
        exit 1
    fi

    local thread_id

    if [[ $use_worktree -eq 1 ]]; then
        thread_id=$(thread_create_with_worktree "$name" "$mode" "$worktree_branch" "$worktree_base" "$template" "$context")

        local worktree_path
        worktree_path=$(thread_get_worktree "$thread_id")

        echo "Thread created: $thread_id"
        echo "  Name:       $name"
        echo "  Mode:       $mode"
        echo "  Template:   ${template:-none}"
        echo "  Worktree:   $worktree_path"
        echo "  Base:       $worktree_base"
    else
        thread_id=$(thread_create "$name" "$mode" "$template" "$workflow" "$context")

        echo "Thread created: $thread_id"
        echo "  Name:     $name"
        echo "  Mode:     $mode"
        echo "  Template: ${template:-none}"
    fi

    echo ""
    echo "Start with: ct thread start $thread_id"
}

cmd_thread_list() {
    local status=""
    local format="${CT_OUTPUT_FORMAT:-text}"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
ct thread list - List threads

USAGE
    ct thread list [status] [options]

OPTIONS
    --format <format>    Output format: text or json (default: text)

STATUSES
    running, ready, waiting, sleeping, completed, failed, created

EXAMPLES
    ct thread list
    ct thread list running
    ct thread list --format json
    ct thread list completed --format json
EOF
                return 0
                ;;
            --format|-f)
                format="${2:-text}"
                if [[ "$format" != "text" && "$format" != "json" ]]; then
                    ct_error_with_hint "Invalid format: $format" "Valid formats: text, json"
                    exit 1
                fi
                shift 2
                ;;
            -*)
                ct_unknown_option "$1" "--format, -f"
                ct_show_help_hint "ct thread list"
                exit 1
                ;;
            *)
                status="$1"
                shift
                ;;
        esac
    done

    local threads
    if [[ -n "$status" ]]; then
        threads=$(db_threads_by_status "$status")
    else
        threads=$(db_query "SELECT * FROM threads ORDER BY updated_at DESC")
    fi

    local count
    count=$(echo "$threads" | jq 'length')

    # Handle JSON format
    if [[ "$format" == "json" ]]; then
        echo "$threads"
        return 0
    fi

    # Text format (default)
    if [[ $count -eq 0 ]]; then
        echo "No threads found"
        return
    fi

    echo "Threads: $count"
    echo ""
    printf "%-20s %-15s %-12s %-10s %s\n" "ID" "NAME" "MODE" "STATUS" "UPDATED"
    printf "%-20s %-15s %-12s %-10s %s\n" "--------------------" "---------------" "------------" "----------" "-------------------"

    echo "$threads" | jq -r '.[] | [.id[:20], .name[:15], .mode, .status, .updated_at[:19]] | @tsv' | \
        while IFS=$'\t' read -r id name mode st updated; do
            printf "%-20s %-15s %-12s %-10s %s\n" "$id" "$name" "$mode" "$st" "$updated"
        done
}

cmd_thread_start() {
    local thread_id=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
ct thread start - Start a thread

USAGE
    ct thread start <thread-id> [options]

OPTIONS
    --verbose, -v    Show detailed progress output

EXAMPLES
    ct thread start thread-1234567890-abcd
    ct thread start thread-1234567890-abcd --verbose
EOF
                return 0
                ;;
            --verbose|-v)
                CT_VERBOSE=1
                shift
                ;;
            -*)
                ct_unknown_option "$1" "--verbose, -v"
                ct_show_help_hint "ct thread start"
                exit 1
                ;;
            *)
                thread_id="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$thread_id" ]]; then
        ct_error_with_hint "Thread ID required" "ct thread start <thread-id>"
        ct_show_help_hint "ct thread start"
        exit 1
    fi

    # Get thread info
    verbose "Fetching thread info: $thread_id"
    local thread
    thread=$(thread_get "$thread_id")

    if [[ -z "$thread" ]]; then
        ct_error_with_hint "Thread not found: $thread_id" "Run 'ct thread list' to see available threads"
        exit 1
    fi

    local status mode
    status=$(echo "$thread" | jq -r '.status')
    mode=$(echo "$thread" | jq -r '.mode')

    verbose "Thread status: $status, mode: $mode"

    echo "Starting thread: $thread_id (mode=$mode)"

    # Transition to ready if needed
    if [[ "$status" == "created" ]]; then
        verbose "Transitioning from created to ready state"
        thread_ready "$thread_id"
    fi

    # Run thread
    verbose "Launching thread runner..."
    case "$mode" in
        automatic)
            "$DATA_DIR/scripts/thread-runner.sh" --thread-id "$thread_id" --data-dir "$DATA_DIR" --background
            echo "Thread started in background"
            verbose "PID file: $DATA_DIR/tmp/thread-${thread_id}.pid"
            ;;
        semi-auto|interactive)
            "$DATA_DIR/scripts/thread-runner.sh" --thread-id "$thread_id" --data-dir "$DATA_DIR"
            ;;
    esac
}

cmd_thread_stop() {
    local thread_id="$1"

    if [[ -z "$thread_id" ]]; then
        echo "Usage: ct thread stop <thread-id>"
        exit 1
    fi

    # Check for running process
    local pid_file="$DATA_DIR/tmp/thread-${thread_id}.pid"
    if [[ -f "$pid_file" ]]; then
        local pid
        pid=$(cat "$pid_file")
        if kill -0 "$pid" 2>/dev/null; then
            echo "Stopping thread process: $pid"
            kill -TERM "$pid"
            rm -f "$pid_file"
        fi
    fi

    # Update status
    thread_wait "$thread_id" "Stopped by user"
    echo "Thread stopped: $thread_id"
}

cmd_thread_status() {
    local thread_id=""
    local format="${CT_OUTPUT_FORMAT:-text}"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
ct thread status - Show thread status

USAGE
    ct thread status <thread-id> [options]

OPTIONS
    --format <format>    Output format: text or json (default: text)

EXAMPLES
    ct thread status thread-1234567890-abcd
    ct thread status thread-1234567890-abcd --format json
EOF
                return 0
                ;;
            --format|-f)
                format="${2:-text}"
                if [[ "$format" != "text" && "$format" != "json" ]]; then
                    ct_error_with_hint "Invalid format: $format" "Valid formats: text, json"
                    exit 1
                fi
                shift 2
                ;;
            -*)
                ct_unknown_option "$1" "--format, -f"
                ct_show_help_hint "ct thread status"
                exit 1
                ;;
            *)
                thread_id="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$thread_id" ]]; then
        ct_error_with_hint "Thread ID required" "ct thread status <thread-id>"
        ct_show_help_hint "ct thread status"
        exit 1
    fi

    local thread
    thread=$(thread_get "$thread_id")

    if [[ -z "$thread" ]]; then
        ct_error_with_hint "Thread not found: $thread_id" "Run 'ct thread list' to see available threads"
        exit 1
    fi

    # Check if running
    local running_pid=""
    local pid_file="$DATA_DIR/tmp/thread-${thread_id}.pid"
    if [[ -f "$pid_file" ]]; then
        local pid
        pid=$(cat "$pid_file")
        if kill -0 "$pid" 2>/dev/null; then
            running_pid="$pid"
        fi
    fi

    # JSON format
    if [[ "$format" == "json" ]]; then
        if [[ -n "$running_pid" ]]; then
            echo "$thread" | jq --arg pid "$running_pid" '. + {running_pid: $pid}'
        else
            echo "$thread"
        fi
        return 0
    fi

    # Text format (default)
    echo "Thread: $thread_id"
    echo "========================================"
    echo ""
    echo "$thread" | jq -r '
        "Name:       \(.name)",
        "Mode:       \(.mode)",
        "Status:     \(.status)",
        "Phase:      \(.phase // "none")",
        "Template:   \(.template // "none")",
        "Session:    \(.session_id // "none")",
        "Created:    \(.created_at)",
        "Updated:    \(.updated_at)",
        "",
        "Context:",
        (.context | tostring)
    '

    if [[ -n "$running_pid" ]]; then
        echo ""
        echo "Process:    Running (PID $running_pid)"
    fi
}

cmd_thread_logs() {
    local thread_id="$1"
    local lines="${2:-50}"

    if [[ -z "$thread_id" ]]; then
        echo "Usage: ct thread logs <thread-id> [lines]"
        exit 1
    fi

    local log_file="$DATA_DIR/logs/thread-${thread_id}.log"
    local output_file="$DATA_DIR/tmp/thread-${thread_id}-output.txt"

    if [[ -f "$log_file" ]]; then
        echo "=== Thread Log ==="
        tail -n "$lines" "$log_file"
    fi

    if [[ -f "$output_file" ]]; then
        echo ""
        echo "=== Last Output ==="
        tail -n "$lines" "$output_file"
    fi

    if [[ ! -f "$log_file" && ! -f "$output_file" ]]; then
        echo "No logs found for thread: $thread_id"
    fi
}

cmd_thread_resume() {
    local thread_id="$1"

    if [[ -z "$thread_id" ]]; then
        echo "Usage: ct thread resume <thread-id>"
        exit 1
    fi

    local thread
    thread=$(thread_get "$thread_id")

    if [[ -z "$thread" ]]; then
        echo "Thread not found: $thread_id"
        exit 1
    fi

    local session_id
    session_id=$(echo "$thread" | jq -r '.session_id // empty')

    if [[ -z "$session_id" ]]; then
        echo "Thread has no session to resume"
        exit 1
    fi

    echo "Resuming thread session: $session_id"
    claude --resume "$session_id"
}

cmd_thread_delete() {
    local thread_id="$1"
    local force="${2:-}"

    if [[ -z "$thread_id" ]]; then
        echo "Usage: ct thread delete <thread-id> [--force]"
        exit 1
    fi

    local thread
    thread=$(thread_get "$thread_id")

    if [[ -z "$thread" ]]; then
        echo "Thread not found: $thread_id"
        exit 1
    fi

    local status
    status=$(echo "$thread" | jq -r '.status')

    if [[ "$status" == "running" && "$force" != "--force" ]]; then
        echo "Thread is running. Stop it first or use --force"
        exit 1
    fi

    # Stop if running
    if [[ "$status" == "running" ]]; then
        cmd_thread_stop "$thread_id"
    fi

    thread_delete "$thread_id"
    echo "Thread deleted: $thread_id"
}

cmd_thread_send() {
    local thread_id=""
    local message=""
    local msg_type="MESSAGE"
    local priority=0

    # Check for help flag first
    for arg in "$@"; do
        if is_help_flag "$arg"; then
            cat <<EOF
ct thread send - Send a message to a running thread

USAGE
    ct thread send <thread-id> <message> [options]

OPTIONS
    --type, -t <type>         Message type (default: MESSAGE)
                              Values: MESSAGE, TASK, FEEDBACK, STOP
    --priority, -p <n>        Priority level (default: 0, higher = more urgent)

MESSAGE TYPES
    MESSAGE     General instruction or information
    TASK        Assign a new task to the thread
    FEEDBACK    Provide feedback on thread's work
    STOP        Request the thread to stop gracefully

EXAMPLES
    ct thread send thread-123 "Please also add input validation"
    ct thread send thread-123 "Review the auth module" --type TASK
    ct thread send thread-123 "Good work, but add more tests" --type FEEDBACK
    ct thread send thread-123 "" --type STOP

NOTE
    The thread must be designed to check its inbox for messages.
    Messages are queued and delivered asynchronously.
EOF
            return 0
        fi
    done

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --type|-t)
                msg_type="$2"
                shift 2
                ;;
            --priority|-p)
                priority="$2"
                shift 2
                ;;
            *)
                if [[ -z "$thread_id" ]]; then
                    thread_id="$1"
                elif [[ -z "$message" ]]; then
                    message="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$thread_id" ]]; then
        echo "Usage: ct thread send <thread-id> <message> [--type TYPE]"
        exit 1
    fi

    # Verify thread exists
    local thread
    thread=$(thread_get "$thread_id")
    if [[ -z "$thread" ]]; then
        ct_error "Thread not found: $thread_id"
        exit 1
    fi

    # Check if API is available
    local api_url
    api_url=$(remote_discover 2>/dev/null || echo "")

    if [[ -z "$api_url" ]]; then
        ct_error_with_hint "API server not running" "Start with: ct api start"
        exit 1
    fi

    # Send message via API
    local payload
    payload=$(jq -n \
        --arg to "$thread_id" \
        --arg type "$msg_type" \
        --arg text "$message" \
        --argjson priority "$priority" \
        '{to: $to, type: $type, content: {text: $text}, priority: $priority}')

    local response
    response=$(curl -s -X POST "$api_url/api/messages" \
        -H "Content-Type: application/json" \
        -d "$payload" 2>/dev/null)

    if echo "$response" | jq -e '.error' >/dev/null 2>&1; then
        ct_error "Failed to send message: $(echo "$response" | jq -r '.error')"
        exit 1
    fi

    echo "‚úâÔ∏è  Message sent to $thread_id"
    echo "   Type: $msg_type"
    [[ -n "$message" ]] && echo "   Content: $message"
}

cmd_thread_inbox() {
    local thread_id="$1"

    # Check for help flag
    if is_help_flag "$thread_id"; then
        cat <<EOF
ct thread inbox - View messages for a thread

USAGE
    ct thread inbox <thread-id>

DESCRIPTION
    Shows all messages in the thread's inbox queue.
    Messages are ordered by priority and timestamp.

EXAMPLES
    ct thread inbox thread-123
EOF
        return 0
    fi

    if [[ -z "$thread_id" ]]; then
        echo "Usage: ct thread inbox <thread-id>"
        exit 1
    fi

    # Verify thread exists
    local thread
    thread=$(thread_get "$thread_id")
    if [[ -z "$thread" ]]; then
        ct_error "Thread not found: $thread_id"
        exit 1
    fi

    # Check if API is available
    local api_url
    api_url=$(remote_discover 2>/dev/null || echo "")

    if [[ -z "$api_url" ]]; then
        ct_error_with_hint "API server not running" "Start with: ct api start"
        exit 1
    fi

    # Get messages via API
    local response
    response=$(curl -s "$api_url/api/messages/$thread_id" 2>/dev/null)

    if echo "$response" | jq -e '.error' >/dev/null 2>&1; then
        ct_error "Failed to get inbox: $(echo "$response" | jq -r '.error')"
        exit 1
    fi

    local count
    count=$(echo "$response" | jq -r '.messages | length')

    if [[ "$count" == "0" ]]; then
        echo "üì≠ Inbox empty for $thread_id"
        return 0
    fi

    echo "üì¨ Inbox for $thread_id ($count messages)"
    echo ""
    echo "$response" | jq -r '.messages[] | "[\(.type)] \(.content.text // .content | tostring) (priority: \(.priority // 0))"'
}

# ============================================================
# Commands: Orchestrator
# ============================================================

cmd_orchestrator() {
    local subcmd="${1:-}"
    shift || true

    # Handle --help at orchestrator level
    if is_help_flag "$subcmd"; then
        show_orchestrator_help
        return 0
    fi

    local orchestrator_script="$DATA_DIR/scripts/orchestrator.sh"

    if [[ ! -f "$orchestrator_script" ]]; then
        ct_error_with_hint "Orchestrator script not found" "Run 'ct init' first to initialize claude-threads"
        exit 1
    fi

    case "$subcmd" in
        start|stop|restart|status|tick)
            "$orchestrator_script" "$subcmd" --data-dir "$DATA_DIR" "$@"
            ;;
        "")
            show_orchestrator_help
            ;;
        *)
            ct_suggest_command "$subcmd" "start" "stop" "restart" "status" "tick"
            ct_show_help_hint "ct orchestrator"
            exit 1
            ;;
    esac
}

# ============================================================
# Commands: Event
# ============================================================

cmd_event() {
    local subcmd="${1:-}"
    shift || true

    # Handle --help at event level
    if is_help_flag "$subcmd"; then
        show_event_help
        return 0
    fi

    case "$subcmd" in
        publish)
            cmd_event_publish "$@"
            ;;
        list|ls)
            cmd_event_list "$@"
            ;;
        "")
            show_event_help
            ;;
        *)
            ct_suggest_command "$subcmd" "publish" "list"
            ct_show_help_hint "ct event"
            exit 1
            ;;
    esac
}

cmd_event_publish() {
    local type="$1"
    local data="${2:-"{}"}"
    local source="${3:-cli}"

    if [[ -z "$type" ]]; then
        echo "Usage: ct event publish <type> [data] [source]"
        exit 1
    fi

    bb_publish "$type" "$data" "$source"
    echo "Event published: $type"
}

cmd_event_list() {
    local limit="${1:-20}"

    local events
    events=$(bb_history "$limit")

    local count
    count=$(echo "$events" | jq 'length')

    if [[ $count -eq 0 ]]; then
        echo "No events found"
        return
    fi

    echo "Recent Events:"
    echo ""
    printf "%-5s %-20s %-20s %-15s %s\n" "ID" "TIMESTAMP" "TYPE" "SOURCE" "PROCESSED"
    printf "%-5s %-20s %-20s %-15s %s\n" "-----" "--------------------" "--------------------" "---------------" "---------"

    echo "$events" | jq -r '.[] | [.id, .timestamp[:19], .type[:20], .source[:15], (if .processed == 1 then "yes" else "no" end)] | @tsv' | \
        while IFS=$'\t' read -r id ts type source processed; do
            printf "%-5s %-20s %-20s %-15s %s\n" "$id" "$ts" "$type" "$source" "$processed"
        done
}

# ============================================================
# Commands: Webhook
# ============================================================

cmd_webhook() {
    local subcmd="${1:-}"
    shift || true

    # Handle --help at webhook level
    if is_help_flag "$subcmd"; then
        show_webhook_help
        return 0
    fi

    local webhook_script="$DATA_DIR/scripts/webhook-server.sh"

    if [[ ! -f "$webhook_script" ]]; then
        ct_error_with_hint "Webhook server script not found" "Run 'ct init' first to initialize claude-threads"
        exit 1
    fi

    case "$subcmd" in
        start|stop|status)
            "$webhook_script" "$subcmd" --data-dir "$DATA_DIR" "$@"
            ;;
        "")
            show_webhook_help
            ;;
        *)
            ct_suggest_command "$subcmd" "start" "stop" "status"
            ct_show_help_hint "ct webhook"
            exit 1
            ;;
    esac
}

# ============================================================
# Commands: API
# ============================================================

cmd_api() {
    local subcmd="${1:-}"
    shift || true

    # Handle --help at api level
    if is_help_flag "$subcmd"; then
        show_api_help
        return 0
    fi

    local api_script="$DATA_DIR/scripts/api-server.sh"

    if [[ ! -f "$api_script" ]]; then
        ct_error_with_hint "API server script not found" "Run 'ct init' first to initialize claude-threads"
        exit 1
    fi

    case "$subcmd" in
        start|stop|status)
            "$api_script" "$subcmd" --data-dir "$DATA_DIR" "$@"
            ;;
        "")
            show_api_help
            ;;
        *)
            ct_suggest_command "$subcmd" "start" "stop" "status"
            ct_show_help_hint "ct api"
            exit 1
            ;;
    esac
}

# ============================================================
# Commands: Debug Dashboard
# ============================================================

cmd_debug() {
    local subcmd="${1:-start}"
    shift || true

    local port="${1:-31339}"
    local debug_script="$DATA_DIR/scripts/debug-server.py"

    if [[ ! -f "$debug_script" ]]; then
        ct_error_with_hint "Debug server script not found" "Reinstall claude-threads to get the debug server"
        exit 1
    fi

    if ! command -v python3 >/dev/null 2>&1; then
        ct_error_with_hint "Python3 is required for the debug server" "Install Python 3: brew install python3"
        exit 1
    fi

    case "$subcmd" in
        start)
            echo "Starting debug dashboard on port $port..."
            python3 "$debug_script" "$port"
            ;;
        -h|--help)
            echo "Usage: ct debug [start] [port]"
            echo ""
            echo "Start the debug web dashboard to monitor threads, events, and logs."
            echo ""
            echo "Options:"
            echo "  port    Port to listen on (default: 31339)"
            echo ""
            echo "Example:"
            echo "  ct debug              # Start on port 31339"
            echo "  ct debug start 8080   # Start on port 8080"
            ;;
        *)
            # Treat as port number
            if [[ "$subcmd" =~ ^[0-9]+$ ]]; then
                port="$subcmd"
                echo "Starting debug dashboard on port $port..."
                python3 "$debug_script" "$port"
            else
                ct_error "Unknown subcommand: $subcmd"
                echo "Usage: ct debug [start] [port]"
                exit 1
            fi
            ;;
    esac
}

# ============================================================
# Commands: Merge
# ============================================================

show_merge_help() {
    cat <<EOF
ct merge - Merge completed thread work

USAGE
    ct merge <subcommand> [options]

SUBCOMMANDS
    thread <id> [strategy]   Merge a specific thread's work
    status <id>              Show merge status for a thread
    config                   Show current merge configuration

STRATEGIES
    direct    Merge worktree branch directly into target (single-repo)
    pr        Create a pull request for review (team workflow)
    none      Leave branch as-is, manual merge required

EXAMPLES
    # Merge thread with configured strategy
    ct merge thread thread-1234567890

    # Force PR strategy for this thread
    ct merge thread thread-1234567890 pr

    # Force direct merge for this thread
    ct merge thread thread-1234567890 direct

    # Check merge status
    ct merge status thread-1234567890

    # Show merge config
    ct merge config

CONFIGURATION
    Set merge strategy in config.yaml:

    merge:
      strategy: pr          # 'direct', 'pr', or 'none'
      target_branch: main   # target for merges
      direct_method: merge  # 'merge', 'rebase', or 'squash'
      pr_auto_merge: false  # auto-merge when CI passes
      on_conflict: block    # 'block', 'resolve', or 'notify'
EOF
}

cmd_merge() {
    local subcmd="${1:-}"
    shift || true

    # Handle --help at merge level
    if is_help_flag "$subcmd"; then
        show_merge_help
        return 0
    fi

    # Source merge library (try DATA_DIR first, then CT_ROOT)
    if [[ -f "$DATA_DIR/lib/merge.sh" ]]; then
        source "$DATA_DIR/lib/merge.sh"
    else
        source "$CT_ROOT/lib/merge.sh"
    fi
    merge_init "$DATA_DIR"

    case "$subcmd" in
        thread)
            local thread_id="${1:-}"
            local strategy="${2:-}"

            if [[ -z "$thread_id" ]]; then
                echo "Usage: ct merge thread <thread_id> [strategy]"
                exit 1
            fi

            # Override strategy if provided
            if [[ -n "$strategy" ]]; then
                # Validate strategy
                case "$strategy" in
                    direct|pr|none) ;;
                    *)
                        echo "Invalid strategy: $strategy"
                        echo "Valid strategies: direct, pr, none"
                        exit 1
                        ;;
                esac
                echo "Using strategy: $strategy"
                # For now, we use the config strategy; full override requires more work
            fi

            echo "Merging thread: $thread_id"
            merge_on_complete "$thread_id"
            ;;
        status)
            local thread_id="${1:-}"

            if [[ -z "$thread_id" ]]; then
                echo "Usage: ct merge status <thread_id>"
                exit 1
            fi

            merge_status "$thread_id"
            ;;
        config)
            echo "Merge Configuration"
            echo "==================="
            echo ""
            echo "Strategy:        $(config_get 'merge.strategy' 'pr')"
            echo "Target Branch:   $(config_get 'merge.target_branch' 'main')"
            echo "Direct Method:   $(config_get 'merge.direct_method' 'merge')"
            echo "PR Auto-merge:   $(config_get 'merge.pr_auto_merge' 'false')"
            echo "Require Approval:$(config_get 'merge.pr_require_approval' 'true')"
            echo "Delete Branch:   $(config_get 'merge.pr_delete_branch' 'true')"
            echo "On Conflict:     $(config_get 'merge.on_conflict' 'block')"
            ;;
        "")
            show_merge_help
            ;;
        *)
            ct_suggest_command "$subcmd" "thread" "status" "config"
            ct_show_help_hint "ct merge"
            exit 1
            ;;
    esac
}

# ============================================================
# Commands: PR (Lifecycle)
# ============================================================

cmd_pr() {
    local subcmd="${1:-}"
    shift || true

    # Handle --help at pr level
    if is_help_flag "$subcmd"; then
        show_pr_help
        return 0
    fi

    local pr_script="$DATA_DIR/scripts/pr-shepherd.sh"

    if [[ ! -f "$pr_script" ]]; then
        ct_error_with_hint "PR shepherd script not found" "Run 'ct init' first to initialize claude-threads"
        exit 1
    fi

    case "$subcmd" in
        watch|status|list|stop|daemon|tick)
            "$pr_script" "$subcmd" --data-dir "$DATA_DIR" "$@"
            ;;
        comments)
            cmd_pr_comments "$@"
            ;;
        conflicts)
            cmd_pr_conflicts "$@"
            ;;
        "")
            show_pr_help
            ;;
        *)
            ct_suggest_command "$subcmd" "watch" "status" "list" "stop" "daemon" "comments" "conflicts"
            ct_show_help_hint "ct pr"
            exit 1
            ;;
    esac
}

cmd_pr_comments() {
    local pr_number="$1"

    if [[ -z "$pr_number" ]]; then
        echo "Usage: ct pr comments <pr_number>"
        exit 1
    fi

    # Source database
    source "$DATA_DIR/lib/db.sh"
    db_init "$DATA_DIR"

    echo "Review Comments for PR #$pr_number"
    echo ""

    local comments
    comments=$(db_pr_comments_get "$pr_number")

    if [[ -z "$comments" || "$comments" == "[]" ]]; then
        echo "No comments tracked for this PR"
        return 0
    fi

    # Count by state
    local pending responded resolved
    pending=$(echo "$comments" | jq '[.[] | select(.state == "pending")] | length')
    responded=$(echo "$comments" | jq '[.[] | select(.state == "responded")] | length')
    resolved=$(echo "$comments" | jq '[.[] | select(.state == "resolved")] | length')

    echo "Summary:"
    echo "  Pending:   $pending"
    echo "  Responded: $responded"
    echo "  Resolved:  $resolved"
    echo ""

    echo "Comments:"
    echo "$comments" | jq -r '.[] | "  [\(.state)] \(.path):\(.line) - @\(.author): \(.body | split("\n")[0][:60])..."'
}

cmd_pr_conflicts() {
    local pr_number="$1"

    if [[ -z "$pr_number" ]]; then
        echo "Usage: ct pr conflicts <pr_number>"
        exit 1
    fi

    # Source database
    source "$DATA_DIR/lib/db.sh"
    db_init "$DATA_DIR"

    echo "Merge Conflicts for PR #$pr_number"
    echo ""

    local conflict
    conflict=$(db_merge_conflict_get_active "$pr_number")

    if [[ -z "$conflict" || "$conflict" == "null" ]]; then
        echo "No active merge conflicts"
        return 0
    fi

    local status target_branch files attempts
    status=$(echo "$conflict" | jq -r '.resolution_status')
    target_branch=$(echo "$conflict" | jq -r '.target_branch')
    files=$(echo "$conflict" | jq -r '.conflicting_files')
    attempts=$(echo "$conflict" | jq -r '.resolution_attempts')

    echo "Status: $status"
    echo "Target Branch: $target_branch"
    echo "Resolution Attempts: $attempts"
    echo ""
    echo "Conflicting Files:"
    echo "$files" | jq -r '.[] | "  - \(.)"'
}

# ============================================================
# Commands: Control (Orchestrator Control Thread)
# ============================================================

cmd_control() {
    local subcmd="${1:-}"
    shift || true

    # Handle --help
    if is_help_flag "$subcmd"; then
        show_control_help
        return 0
    fi

    case "$subcmd" in
        start)
            cmd_control_start "$@"
            ;;
        status)
            cmd_control_status
            ;;
        stop)
            cmd_control_stop
            ;;
        "")
            show_control_help
            ;;
        *)
            ct_suggest_command "$subcmd" "start" "status" "stop"
            ct_show_help_hint "ct control"
            exit 1
            ;;
    esac
}

cmd_control_start() {
    local auto_merge=0
    local interactive=0

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --auto-merge)
                auto_merge=1
                shift
                ;;
            --interactive)
                interactive=1
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    local mode="autonomous"
    [[ $interactive -eq 1 ]] && mode="interactive"

    echo "Starting orchestrator control thread..."

    # Source required libraries
    source "$DATA_DIR/lib/db.sh"
    source "$DATA_DIR/lib/state.sh"
    db_init "$DATA_DIR"

    # First ensure orchestrator is running
    local orch_script="$DATA_DIR/scripts/orchestrator.sh"
    if [[ -f "$orch_script" ]]; then
        "$orch_script" status --data-dir "$DATA_DIR" >/dev/null 2>&1 || {
            echo "Starting orchestrator daemon..."
            "$orch_script" start --data-dir "$DATA_DIR"
        }
    fi

    # Create and start control thread
    local context
    context=$(jq -n \
        --arg mode "$mode" \
        --argjson auto_merge "$auto_merge" \
        --argjson interactive "$interactive" \
        '{mode: $mode, auto_merge: ($auto_merge == 1), interactive: ($interactive == 1), poll_interval: 30}')

    local thread_id
    thread_id=$(thread_create "orchestrator-control" "automatic" "templates/prompts/orchestrator-control.md" "" "$context")

    if [[ -z "$thread_id" ]]; then
        ct_error "Failed to create control thread"
        exit 1
    fi

    # Store control thread ID
    echo "$thread_id" > "$DATA_DIR/control-thread.id"

    # Start the thread
    thread_ready "$thread_id"

    echo "Control thread started: $thread_id"
    echo "  Mode: $mode"
    echo "  Auto-merge: $([[ $auto_merge -eq 1 ]] && echo "enabled" || echo "disabled")"
    echo ""
    echo "Use 'ct control status' to check status"
    echo "Use 'ct control stop' to stop"
}

cmd_control_status() {
    local control_thread_file="$DATA_DIR/control-thread.id"

    if [[ ! -f "$control_thread_file" ]]; then
        echo "Control thread is not running"
        return 0
    fi

    local thread_id
    thread_id=$(cat "$control_thread_file")

    # Source database
    source "$DATA_DIR/lib/db.sh"
    db_init "$DATA_DIR"

    local thread
    thread=$(db_thread_get "$thread_id")

    if [[ -z "$thread" || "$thread" == "null" ]]; then
        echo "Control thread not found (stale reference)"
        rm -f "$control_thread_file"
        return 1
    fi

    local status mode
    status=$(echo "$thread" | jq -r '.status')
    mode=$(echo "$thread" | jq -r '.context.mode // "autonomous"')

    echo "Control Thread Status"
    echo ""
    echo "  Thread ID: $thread_id"
    echo "  Status: $status"
    echo "  Mode: $mode"
    echo ""

    # Show watched PRs
    echo "Watched PRs:"
    local prs
    prs=$(db_query "SELECT pr_number, state, has_merge_conflict, comments_pending, comments_resolved FROM pr_watches WHERE state NOT IN ('merged', 'closed')" 2>/dev/null || echo "[]")

    if [[ "$prs" == "[]" || -z "$prs" ]]; then
        echo "  None"
    else
        echo "$prs" | jq -r '.[] | "  PR #\(.pr_number): \(.state) (conflicts: \(.has_merge_conflict), comments: \(.comments_pending)/\(.comments_resolved))"'
    fi
}

cmd_control_stop() {
    local control_thread_file="$DATA_DIR/control-thread.id"

    if [[ ! -f "$control_thread_file" ]]; then
        echo "Control thread is not running"
        return 0
    fi

    local thread_id
    thread_id=$(cat "$control_thread_file")

    echo "Stopping control thread: $thread_id"

    # Source required libraries
    source "$DATA_DIR/lib/db.sh"
    source "$DATA_DIR/lib/state.sh"
    db_init "$DATA_DIR"

    # Stop the thread
    thread_stop "$thread_id" 2>/dev/null || true

    rm -f "$control_thread_file"

    echo "Control thread stopped"
}

# ============================================================
# Commands: Session
# ============================================================

cmd_session() {
    local subcmd="${1:-}"
    shift || true

    # Handle --help
    if is_help_flag "$subcmd"; then
        show_session_help
        return 0
    fi

    # Source session library
    if [[ -f "$DATA_DIR/lib/session.sh" ]]; then
        source "$DATA_DIR/lib/session.sh"
    else
        ct_error "Session library not found. Run 'ct migrate --up' first."
        exit 1
    fi

    case "$subcmd" in
        start)
            cmd_session_start "$@"
            ;;
        resume)
            cmd_session_resume "$@"
            ;;
        fork)
            cmd_session_fork "$@"
            ;;
        history)
            cmd_session_history "$@"
            ;;
        checkpoint)
            cmd_session_checkpoint "$@"
            ;;
        coordinate)
            cmd_session_coordinate "$@"
            ;;
        "")
            show_session_help
            ;;
        *)
            ct_suggest_command "$subcmd" "start" "resume" "fork" "history" "checkpoint" "coordinate"
            ct_show_help_hint "ct session"
            exit 1
            ;;
    esac
}

cmd_session_start() {
    local thread_id="${1:-}"

    if [[ -z "$thread_id" ]]; then
        ct_error "Thread ID required"
        echo "Usage: ct session start <thread-id>"
        exit 1
    fi

    local session_id
    session_id=$(session_start "$thread_id")

    echo "Session started: $session_id"
    echo "  Thread: $thread_id"
}

cmd_session_resume() {
    local session_id="${1:-}"

    if [[ -z "$session_id" ]]; then
        ct_error "Session ID required"
        echo "Usage: ct session resume <session-id>"
        exit 1
    fi

    local thread_id
    thread_id=$(session_resume "$session_id")

    if [[ -n "$thread_id" ]]; then
        echo "Session resumed"
        echo "  Thread: $thread_id"
        echo "  Session: $session_id"
    fi
}

cmd_session_fork() {
    local thread_id="${1:-}"

    if [[ -z "$thread_id" ]]; then
        ct_error "Thread ID required"
        echo "Usage: ct session fork <thread-id>"
        exit 1
    fi

    local new_session_id
    new_session_id=$(session_fork "$thread_id")

    echo "Session forked: $new_session_id"
    echo "  Thread: $thread_id"
    echo "  Parent session preserved"
}

cmd_session_history() {
    local thread_id="${1:-}"
    local limit="${2:-10}"

    if [[ -z "$thread_id" ]]; then
        ct_error "Thread ID required"
        echo "Usage: ct session history <thread-id> [limit]"
        exit 1
    fi

    local history
    history=$(session_history "$thread_id" "$limit")

    echo "Session History for $thread_id:"
    echo ""
    echo "$history" | jq -r '.[] | "  \(.session_id)\t\(.status)\t\(.started_at)"'
}

cmd_session_checkpoint() {
    local thread_id=""
    local checkpoint_type="manual"
    local show_latest=0
    local state_summary=""
    local pending_tasks="[]"
    local context_snapshot=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --thread-id)
                thread_id="$2"
                shift 2
                ;;
            --type)
                checkpoint_type="$2"
                shift 2
                ;;
            --latest)
                show_latest=1
                shift
                ;;
            --state-summary)
                state_summary="$2"
                shift 2
                ;;
            --pending-tasks)
                pending_tasks="$2"
                shift 2
                ;;
            --context-snapshot)
                context_snapshot="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ -z "$thread_id" ]]; then
        ct_error "Thread ID required (--thread-id)"
        exit 1
    fi

    if [[ $show_latest -eq 1 ]]; then
        local checkpoint
        checkpoint=$(checkpoint_get_latest "$thread_id")

        if [[ -z "$checkpoint" || "$checkpoint" == "null" ]]; then
            echo "No checkpoints found for thread $thread_id"
        else
            echo "Latest Checkpoint:"
            echo "$checkpoint" | jq '.'
        fi
    else
        checkpoint_create "$thread_id" "$checkpoint_type" "$state_summary" "[]" "$pending_tasks" "$context_snapshot"
        echo "Checkpoint created"
        echo "  Thread: $thread_id"
        echo "  Type: $checkpoint_type"
    fi
}

cmd_session_coordinate() {
    local register=0
    local update_context=0
    local due_checkpoints=0
    local orchestrator_session=""
    local agent_thread=""
    local shared_context=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --register)
                register=1
                shift
                ;;
            --update-context)
                update_context=1
                shift
                ;;
            --due-checkpoints)
                due_checkpoints=1
                shift
                ;;
            --orchestrator-session)
                orchestrator_session="$2"
                shift 2
                ;;
            --agent-thread)
                agent_thread="$2"
                shift 2
                ;;
            --shared-context)
                shared_context="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ $register -eq 1 ]]; then
        if [[ -z "$orchestrator_session" || -z "$agent_thread" ]]; then
            ct_error "Both --orchestrator-session and --agent-thread required"
            exit 1
        fi

        coordination_register "$orchestrator_session" "$agent_thread"
        echo "Agent registered for coordination"
        echo "  Orchestrator: $orchestrator_session"
        echo "  Agent: $agent_thread"
    elif [[ $update_context -eq 1 ]]; then
        if [[ -z "$agent_thread" ]]; then
            ct_error "--agent-thread required"
            exit 1
        fi

        coordination_update_state "$agent_thread" "active" "$shared_context"
        echo "Coordination context updated"
    elif [[ $due_checkpoints -eq 1 ]]; then
        local due
        due=$(coordination_get_due_checkpoints)

        if [[ -z "$due" || "$due" == "[]" ]]; then
            echo "No agents need checkpoint"
        else
            echo "Agents needing checkpoint:"
            echo "$due" | jq -r '.[] | "  \(.agent_thread_id)\t\(.next_checkpoint_at)"'
        fi
    else
        show_session_help
    fi
}

# ============================================================
# Commands: Memory
# ============================================================

cmd_memory() {
    local subcmd="${1:-}"
    shift || true

    # Handle --help
    if is_help_flag "$subcmd"; then
        show_memory_help
        return 0
    fi

    # Source session library (contains memory functions)
    if [[ -f "$DATA_DIR/lib/session.sh" ]]; then
        source "$DATA_DIR/lib/session.sh"
    else
        ct_error "Session library not found. Run 'ct migrate --up' first."
        exit 1
    fi

    case "$subcmd" in
        set)
            cmd_memory_set "$@"
            ;;
        get)
            cmd_memory_get "$@"
            ;;
        list)
            cmd_memory_list "$@"
            ;;
        delete)
            cmd_memory_delete "$@"
            ;;
        summary)
            cmd_memory_summary "$@"
            ;;
        cleanup)
            memory_cleanup_expired
            echo "Expired memories cleaned up"
            ;;
        "")
            show_memory_help
            ;;
        *)
            ct_suggest_command "$subcmd" "set" "get" "list" "delete" "summary" "cleanup"
            ct_show_help_hint "ct memory"
            exit 1
            ;;
    esac
}

cmd_memory_set() {
    local thread_id=""
    local category=""
    local key=""
    local value=""
    local importance=5

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --thread-id)
                thread_id="$2"
                shift 2
                ;;
            --category)
                category="$2"
                shift 2
                ;;
            --key)
                key="$2"
                shift 2
                ;;
            --value)
                value="$2"
                shift 2
                ;;
            --importance)
                importance="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ -z "$category" || -z "$key" || -z "$value" ]]; then
        ct_error "Required: --category, --key, --value"
        exit 1
    fi

    memory_set "$thread_id" "$category" "$key" "$value" "$importance"
    echo "Memory stored"
    echo "  Category: $category"
    echo "  Key: $key"
    echo "  Thread: ${thread_id:-global}"
}

cmd_memory_get() {
    local thread_id=""
    local category=""
    local key=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --thread-id)
                thread_id="$2"
                shift 2
                ;;
            --category)
                category="$2"
                shift 2
                ;;
            --key)
                key="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ -z "$category" || -z "$key" ]]; then
        ct_error "Required: --category, --key"
        exit 1
    fi

    local value
    value=$(memory_get "$thread_id" "$category" "$key")

    if [[ -n "$value" ]]; then
        echo "$value"
    else
        echo "Memory not found"
        exit 1
    fi
}

cmd_memory_list() {
    local thread_id=""
    local category=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --thread-id)
                thread_id="$2"
                shift 2
                ;;
            --category)
                category="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    local memories
    memories=$(memory_get_all "$thread_id" "$category")

    if [[ -z "$memories" || "$memories" == "[]" ]]; then
        echo "No memories found"
    else
        echo "$memories" | jq -r '.[] | "\(.category)/\(.key): \(.value) (importance: \(.importance))"'
    fi
}

cmd_memory_delete() {
    local thread_id=""
    local category=""
    local key=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --thread-id)
                thread_id="$2"
                shift 2
                ;;
            --category)
                category="$2"
                shift 2
                ;;
            --key)
                key="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ -z "$category" || -z "$key" ]]; then
        ct_error "Required: --category, --key"
        exit 1
    fi

    memory_delete "$thread_id" "$category" "$key"
    echo "Memory deleted"
}

cmd_memory_summary() {
    local thread_id=""
    local max_entries=20

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --thread-id)
                thread_id="$2"
                shift 2
                ;;
            --max)
                max_entries="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ -z "$thread_id" ]]; then
        ct_error "Required: --thread-id"
        exit 1
    fi

    local summary
    summary=$(memory_get_context_summary "$thread_id" "$max_entries")

    if [[ -n "$summary" ]]; then
        echo "$summary"
    else
        echo "No memories found for thread"
    fi
}

# ============================================================
# Commands: Worktree
# ============================================================

cmd_worktree() {
    local subcmd="${1:-}"
    shift || true

    # Handle --help at worktree level
    if is_help_flag "$subcmd"; then
        show_worktree_help
        return 0
    fi

    case "$subcmd" in
        list|ls)
            cmd_worktree_list "$@"
            ;;
        status)
            cmd_worktree_status "$@"
            ;;
        cleanup)
            cmd_worktree_cleanup "$@"
            ;;
        # PR Base Worktree commands
        base-create)
            cmd_worktree_base_create "$@"
            ;;
        base-update)
            cmd_worktree_base_update "$@"
            ;;
        base-status)
            cmd_worktree_base_status "$@"
            ;;
        base-remove)
            cmd_worktree_base_remove "$@"
            ;;
        fork)
            cmd_worktree_fork "$@"
            ;;
        merge-back)
            cmd_worktree_merge_back "$@"
            ;;
        remove-fork)
            cmd_worktree_remove_fork "$@"
            ;;
        list-forks)
            cmd_worktree_list_forks "$@"
            ;;
        reconcile)
            cmd_worktree_reconcile "$@"
            ;;
        "")
            show_worktree_help
            ;;
        *)
            ct_suggest_command "$subcmd" "list" "status" "cleanup" "base-create" "base-update" "base-status" "base-remove" "fork" "merge-back" "remove-fork" "list-forks" "reconcile"
            ct_show_help_hint "ct worktree"
            exit 1
            ;;
    esac
}

cmd_worktree_list() {
    echo "Active Worktrees:"
    echo ""

    local worktrees
    worktrees=$(git_worktree_list)

    if [[ -z "$worktrees" ]]; then
        echo "No active worktrees"
        return
    fi

    printf "%-20s %-30s %-10s %s\n" "THREAD ID" "BRANCH" "STATUS" "PATH"
    printf "%-20s %-30s %-10s %s\n" "--------------------" "------------------------------" "----------" "----"

    echo "$worktrees" | while IFS='|' read -r thread_id branch status path; do
        printf "%-20s %-30s %-10s %s\n" "${thread_id:0:20}" "${branch:0:30}" "$status" "$path"
    done
}

cmd_worktree_status() {
    local thread_id="$1"

    if [[ -z "$thread_id" ]]; then
        echo "Usage: ct worktree status <thread-id>"
        exit 1
    fi

    local info
    info=$(git_worktree_info "$thread_id")

    if [[ -z "$info" || "$info" == "{}" ]]; then
        echo "No worktree found for thread: $thread_id"
        exit 1
    fi

    echo "Worktree Status: $thread_id"
    echo "=========================="
    echo ""
    echo "$info" | jq -r '
        "Path:            \(.path)",
        "Branch:          \(.branch)",
        "Status:          \(.status)",
        "Commits ahead:   \(.commits_ahead)",
        "Commits behind:  \(.commits_behind)"
    '
}

cmd_worktree_cleanup() {
    local force="${1:-}"
    local max_age="${2:-7}"

    echo "Cleaning up worktrees..."

    # Cleanup orphaned worktrees
    thread_cleanup_orphaned_worktrees

    # Cleanup old worktrees
    if [[ "$force" == "--force" || "$force" == "-f" ]]; then
        git_cleanup_old_worktrees "$max_age"
    fi

    # Prune git worktrees
    git_worktree_prune

    echo "Cleanup complete"
}

# ============================================================
# Commands: Worktree - PR Base (Memory Optimization)
# ============================================================

cmd_worktree_base_create() {
    local pr_number="${1:-}"
    local branch="${2:-}"
    local target_branch="${3:-main}"
    local remote="${4:-origin}"

    if [[ -z "$pr_number" || -z "$branch" ]]; then
        echo "Usage: ct worktree base-create <pr_number> <branch> [target_branch] [remote]"
        echo ""
        echo "Creates or updates a base worktree for a PR."
        echo "Sub-agents can fork from this base for memory efficiency."
        exit 1
    fi

    # Validate PR number is numeric
    if [[ ! "$pr_number" =~ ^[0-9]+$ ]]; then
        echo "Error: PR number must be a positive integer"
        exit 1
    fi

    local base_path
    if ! base_path=$(git_pr_base_create "$pr_number" "$branch" "$target_branch" "$remote"); then
        echo "Error: Failed to create base worktree"
        exit 1
    fi

    if [[ -n "$base_path" ]]; then
        echo "PR Base Worktree: $base_path"
    fi
}

cmd_worktree_base_update() {
    local pr_number="${1:-}"
    local remote="${2:-origin}"

    if [[ -z "$pr_number" ]]; then
        echo "Usage: ct worktree base-update <pr_number> [remote]"
        exit 1
    fi

    # Validate PR number is numeric
    if [[ ! "$pr_number" =~ ^[0-9]+$ ]]; then
        echo "Error: PR number must be a positive integer"
        exit 1
    fi

    if ! git_pr_base_update "$pr_number" "$remote"; then
        echo "Error: Failed to update base worktree"
        exit 1
    fi
}

cmd_worktree_base_status() {
    local pr_number="${1:-}"

    if [[ -z "$pr_number" ]]; then
        echo "Usage: ct worktree base-status <pr_number>"
        exit 1
    fi

    local info
    info=$(git_pr_base_info "$pr_number")

    if [[ -z "$info" || "$info" == "{}" ]]; then
        echo "No base worktree found for PR #$pr_number"
        exit 1
    fi

    echo "PR #$pr_number Base Worktree Status"
    echo "===================================="
    echo ""
    echo "$info" | jq -r '
        "Base ID:       \(.base_id)",
        "Path:          \(.path)",
        "Branch:        \(.branch)",
        "Status:        \(.status)",
        "Fork Count:    \(.fork_count)",
        "",
        "Active Forks:"
    '
    echo ""

    local forks
    forks=$(echo "$info" | jq -r '.forks[]? | "  - \(.id) (\(.branch)) [\(.status)]"')
    if [[ -n "$forks" ]]; then
        echo "$forks"
    else
        echo "  (none)"
    fi
}

cmd_worktree_base_remove() {
    local pr_number="${1:-}"
    local force="${2:-}"

    if [[ -z "$pr_number" ]]; then
        echo "Usage: ct worktree base-remove <pr_number> [--force]"
        exit 1
    fi

    local force_flag="false"
    if [[ "$force" == "--force" || "$force" == "-f" ]]; then
        force_flag="true"
    fi

    git_pr_base_remove "$pr_number" "$force_flag"
}

cmd_worktree_fork() {
    local pr_number="${1:-}"
    local fork_id="${2:-}"
    local fork_branch="${3:-}"
    local purpose="${4:-general}"
    local handler_thread_id="${5:-}"

    if [[ -z "$pr_number" || -z "$fork_id" || -z "$fork_branch" ]]; then
        echo "Usage: ct worktree fork <pr_number> <fork_id> <fork_branch> [purpose] [handler_thread_id]"
        echo ""
        echo "Creates a fork from the PR base worktree."
        echo "Forks share git objects with the base for memory efficiency."
        echo ""
        echo "Purpose options: conflict_resolution, comment_handler, ci_fix, general"
        exit 1
    fi

    # Validate PR number is numeric
    if [[ ! "$pr_number" =~ ^[0-9]+$ ]]; then
        echo "Error: PR number must be a positive integer"
        exit 1
    fi

    # Validate fork_id doesn't contain dangerous characters
    if [[ "$fork_id" =~ [^a-zA-Z0-9_-] ]]; then
        echo "Error: Fork ID can only contain alphanumeric characters, dashes, and underscores"
        exit 1
    fi

    local fork_path
    if ! fork_path=$(git_worktree_fork "$pr_number" "$fork_id" "$fork_branch" "$purpose" "$handler_thread_id"); then
        echo "Error: Failed to create fork"
        exit 1
    fi

    if [[ -n "$fork_path" ]]; then
        echo "$fork_path"
    fi
}

cmd_worktree_merge_back() {
    local fork_id="${1:-}"
    local push="${2:-true}"

    if [[ -z "$fork_id" ]]; then
        echo "Usage: ct worktree merge-back <fork_id> [--no-push]"
        exit 1
    fi

    # Validate fork_id doesn't contain dangerous characters
    if [[ "$fork_id" =~ [^a-zA-Z0-9_-] ]]; then
        echo "Error: Fork ID can only contain alphanumeric characters, dashes, and underscores"
        exit 1
    fi

    if [[ "$push" == "--no-push" ]]; then
        push="false"
    else
        push="true"
    fi

    local result
    git_fork_merge_back "$fork_id" "$push"
    result=$?

    case $result in
        0) echo "Fork merged successfully" ;;
        1)
            echo "Error: Merge failed (possibly due to conflicts)"
            exit 1
            ;;
        2)
            echo "Warning: Merge succeeded but push failed"
            echo "Changes are local only - push manually when ready"
            exit 2
            ;;
    esac
}

cmd_worktree_remove_fork() {
    local fork_id="${1:-}"
    local force="${2:-}"

    if [[ -z "$fork_id" ]]; then
        echo "Usage: ct worktree remove-fork <fork_id> [--force]"
        exit 1
    fi

    local force_flag="false"
    if [[ "$force" == "--force" || "$force" == "-f" ]]; then
        force_flag="true"
    fi

    git_fork_remove "$fork_id" "$force_flag"
}

cmd_worktree_list_forks() {
    local pr_number="${1:-}"

    if [[ -z "$pr_number" ]]; then
        echo "Usage: ct worktree list-forks <pr_number>"
        exit 1
    fi

    # Validate PR number is numeric
    if [[ ! "$pr_number" =~ ^[0-9]+$ ]]; then
        echo "Error: PR number must be a positive integer"
        exit 1
    fi

    echo "Forks for PR #$pr_number:"
    echo ""

    local forks
    forks=$(git_pr_forks_list "$pr_number")

    if [[ -z "$forks" ]]; then
        echo "No active forks"
        return
    fi

    printf "%-25s %-25s %-10s %-15s %s\n" "FORK ID" "BRANCH" "STATUS" "PURPOSE" "PATH"
    printf "%-25s %-25s %-10s %-15s %s\n" "-------------------------" "-------------------------" "----------" "---------------" "----"

    echo "$forks" | while IFS='|' read -r fork_id branch status purpose path; do
        printf "%-25s %-25s %-10s %-15s %s\n" "${fork_id:0:25}" "${branch:0:25}" "$status" "${purpose:-general}" "$path"
    done
}

cmd_worktree_reconcile() {
    local fix="${1:-}"

    echo "PR Worktree Reconciliation"
    echo "=========================="
    echo ""

    local fix_flag="false"
    if [[ "$fix" == "--fix" || "$fix" == "-f" ]]; then
        fix_flag="true"
        echo "Mode: FIX (will repair issues)"
    else
        echo "Mode: CHECK (dry run - use --fix to repair)"
    fi
    echo ""

    git_pr_worktree_reconcile "$fix_flag"
}

# ============================================================
# Commands: Migrate
# ============================================================

cmd_migrate() {
    local migrate_script="$CT_ROOT/scripts/migrate.sh"

    if [[ ! -f "$migrate_script" ]]; then
        echo "Error: Migration script not found"
        exit 1
    fi

    "$migrate_script" --db "$DATA_DIR/threads.db" "$@"
}

# ============================================================
# Commands: Remote
# ============================================================

cmd_remote() {
    local subcmd="${1:-}"
    shift || true

    # Handle --help at remote level
    if is_help_flag "$subcmd"; then
        show_remote_help
        return 0
    fi

    case "$subcmd" in
        connect)
            cmd_remote_connect "$@"
            ;;
        disconnect)
            cmd_remote_disconnect "$@"
            ;;
        status)
            cmd_remote_status "$@"
            ;;
        discover)
            cmd_remote_discover "$@"
            ;;
        "")
            show_remote_help
            ;;
        *)
            ct_suggest_command "$subcmd" "connect" "disconnect" "status" "discover"
            ct_show_help_hint "ct remote"
            exit 1
            ;;
    esac
}

cmd_remote_connect() {
    local endpoint=""
    local token=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --token|-t)
                token="$2"
                shift 2
                ;;
            -*)
                echo "Unknown option: $1"
                exit 1
                ;;
            *)
                endpoint="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$endpoint" ]]; then
        echo "Usage: ct remote connect <host:port> [--token TOKEN]"
        exit 1
    fi

    # Use provided token or environment variable
    token="${token:-${CT_API_TOKEN:-${N8N_API_TOKEN:-}}}"

    if remote_connect "$endpoint" "$token"; then
        echo "Connected to $endpoint"
        echo ""
        remote_status
    else
        echo "Failed to connect to $endpoint"
        exit 1
    fi
}

cmd_remote_disconnect() {
    remote_disconnect
    echo "Disconnected from remote orchestrator"
}

cmd_remote_status() {
    remote_status
}

cmd_remote_discover() {
    echo "Discovering running orchestrator..."

    if remote_discover "$DATA_DIR"; then
        echo ""
        remote_status
    else
        echo "No running orchestrator found"
        echo ""
        echo "Make sure the API server is running:"
        echo "  ct api start --token <token>"
        exit 1
    fi
}

# ============================================================
# Commands: Instances
# ============================================================

show_instances_help() {
    cat <<EOF
ct instances - Manage running claude-threads instances

USAGE
    ct instances <subcommand>

SUBCOMMANDS
    list, ls      List all running instances
    show <port>   Show details for a specific instance
    cleanup       Remove stale instances from registry
    discover      Auto-discover and connect to an instance

EXAMPLES
    ct instances list
    ct instances show 31340
    ct instances cleanup
    ct instances discover

NOTES
    Instances are automatically registered when starting API servers.
    Use --port=auto with 'ct api start' to enable dynamic port allocation.
EOF
}

cmd_instances() {
    local subcmd="${1:-list}"
    shift || true

    # Handle --help
    if is_help_flag "$subcmd"; then
        show_instances_help
        return 0
    fi

    case "$subcmd" in
        list|ls)
            cmd_instances_list "$@"
            ;;
        show)
            cmd_instances_show "$@"
            ;;
        cleanup)
            cmd_instances_cleanup "$@"
            ;;
        discover)
            cmd_instances_discover "$@"
            ;;
        "")
            cmd_instances_list "$@"
            ;;
        *)
            ct_suggest_command "$subcmd" "list" "show" "cleanup" "discover"
            ct_show_help_hint "ct instances"
            exit 1
            ;;
    esac
}

cmd_instances_list() {
    remote_list_instances
}

cmd_instances_show() {
    local port="${1:-}"

    if [[ -z "$port" ]]; then
        echo "Usage: ct instances show <port>"
        exit 1
    fi

    local instance
    instance=$(registry_get_instance "$port")

    if [[ -z "$instance" || "$instance" == "null" ]]; then
        echo "No instance found on port $port"
        exit 1
    fi

    echo "Instance on port $port"
    echo "======================"
    echo ""
    echo "$instance" | jq -r '
        "Project: \(.project_root)",
        "PID: \(.pid)",
        "Started: \(.started_at)",
        "Last Heartbeat: \(.last_heartbeat)",
        "",
        "Services:",
        (.services | to_entries[] | "  \(.key): port \(.value.port), pid \(.value.pid)"),
        "",
        "Metadata:",
        "  Threads: \(.metadata.threads_active // 0) active / \(.metadata.threads_total // 0) total",
        "  Recent Events: \(.metadata.recent_events | join(", ") // "none")"
    '
}

cmd_instances_cleanup() {
    local timeout="${1:-30}"
    echo "Cleaning up stale instances (timeout: ${timeout}s)..."

    local removed
    removed=$(registry_cleanup_stale "$timeout")

    if [[ "$removed" -gt 0 ]]; then
        echo "Removed $removed stale instance(s)"
    else
        echo "No stale instances found"
    fi
}

cmd_instances_discover() {
    echo "Discovering instances from registry..."
    echo ""

    local port
    port=$(registry_discover 2>/dev/null) || true

    if [[ -n "$port" ]]; then
        echo "Found instance on port $port"
        echo ""

        # Try to connect
        if remote_connect "localhost:$port"; then
            echo ""
            remote_status
        fi
    else
        echo "No instances found in registry"
        echo ""
        echo "Start an API server with automatic port allocation:"
        echo "  ct api start --port=auto --token <token>"
    fi
}

# ============================================================
# Commands: Spawn
# ============================================================

cmd_spawn() {
    local name=""
    local template=""
    local mode="automatic"
    local context="{}"
    local use_worktree=""  # Empty means: auto (default for remote, optional for local)
    local worktree_base="main"
    local wait_completion=0
    local use_remote=""

    # Check for help flag first
    for arg in "$@"; do
        if is_help_flag "$arg"; then
            show_spawn_help
            return 0
        fi
    done

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --template|-t)
                template="$2"
                shift 2
                ;;
            --mode|-m)
                mode="$2"
                shift 2
                ;;
            --context|-c)
                context="$2"
                shift 2
                ;;
            --worktree|-w)
                use_worktree=1
                shift
                ;;
            --no-worktree)
                use_worktree=0
                shift
                ;;
            --worktree-base)
                worktree_base="$2"
                use_worktree=1
                shift 2
                ;;
            --wait)
                wait_completion=1
                shift
                ;;
            --remote)
                use_remote="1"
                shift
                ;;
            --local)
                use_remote="0"
                shift
                ;;
            --verbose|-v)
                CT_VERBOSE=1
                shift
                ;;
            -*)
                ct_unknown_option "$1" "--template, -t" "--mode, -m" "--context, -c" "--worktree, -w" "--no-worktree" "--worktree-base" "--wait" "--remote" "--local" "--verbose, -v"
                ct_show_help_hint "ct spawn"
                exit 1
                ;;
            *)
                name="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$name" ]]; then
        show_spawn_help
        exit 1
    fi

    verbose "Parsing spawn options"
    verbose "  Name: $name"
    verbose "  Mode: $mode"
    verbose "  Template: ${template:-none}"
    verbose "  Context: $context"

    # Determine whether to use remote or local
    local use_remote_api=0
    if [[ "$use_remote" == "1" ]]; then
        use_remote_api=1
        verbose "Using remote API (forced via --remote)"
    elif [[ "$use_remote" == "0" ]]; then
        use_remote_api=0
        verbose "Using local database (forced via --local)"
    elif remote_is_connected; then
        use_remote_api=1
        verbose "Using remote API (auto-detected connection)"
    else
        verbose "Using local database (no remote connection)"
    fi

    if [[ $use_remote_api -eq 1 ]]; then
        if ! remote_is_connected; then
            echo "Error: Not connected to remote orchestrator"
            echo "Run 'ct remote connect <host:port>' first"
            exit 1
        fi

        # For remote, worktree is DEFAULT (required for isolation)
        # Only disable if explicitly requested with --no-worktree
        if [[ -z "$use_worktree" ]]; then
            use_worktree=1  # Default to enabled for remote
            verbose "Worktree: enabled (default for remote)"
        fi

        echo "Spawning thread via remote API: $name"

        # Build spawn arguments - worktree is handled by remote_spawn (default enabled)
        local spawn_args=("$name")
        [[ -n "$template" ]] && spawn_args+=(--template "$template")
        spawn_args+=(--mode "$mode")
        spawn_args+=(--context "$context")
        spawn_args+=(--worktree-base "$worktree_base")
        [[ $use_worktree -eq 0 ]] && spawn_args+=(--no-worktree)
        [[ $wait_completion -eq 1 ]] && spawn_args+=(--wait)

        verbose "Calling remote_spawn with args: ${spawn_args[*]}"
        remote_spawn "${spawn_args[@]}"
    else
        echo "Spawning thread locally: $name"

        # For local, worktree is optional (default disabled unless specified)
        if [[ -z "$use_worktree" ]]; then
            use_worktree=0  # Default to disabled for local
            verbose "Worktree: disabled (default for local)"
        fi

        # Create thread locally
        verbose "Creating thread in database..."
        local thread_id
        if [[ $use_worktree -eq 1 ]]; then
            verbose "Creating worktree with base branch: $worktree_base"
            thread_id=$(thread_create_with_worktree "$name" "$mode" "" "$worktree_base" "$template" "$context")
            local worktree_path
            worktree_path=$(thread_get_worktree "$thread_id" 2>/dev/null || echo "")
            echo "Created thread: $thread_id"
            [[ -n "$worktree_path" ]] && echo "Worktree: $worktree_path"
        else
            thread_id=$(thread_create "$name" "$mode" "$template" "" "$context")
            echo "Created thread: $thread_id"
        fi

        # Start thread
        verbose "Transitioning thread to ready state..."
        thread_ready "$thread_id"

        verbose "Starting thread runner (mode=$mode)..."
        case "$mode" in
            automatic)
                "$DATA_DIR/scripts/thread-runner.sh" --thread-id "$thread_id" --data-dir "$DATA_DIR" --background
                echo "Thread started in background"
                verbose "Thread runner PID file: $DATA_DIR/tmp/thread-${thread_id}.pid"
                ;;
            semi-auto|interactive)
                "$DATA_DIR/scripts/thread-runner.sh" --thread-id "$thread_id" --data-dir "$DATA_DIR"
                ;;
        esac

        # Wait if requested
        if [[ $wait_completion -eq 1 && "$mode" == "automatic" ]]; then
            echo "Waiting for completion..."
            verbose "Polling thread status every 5 seconds..."
            while true; do
                local status
                status=$(thread_get "$thread_id" | jq -r '.status // empty')
                verbose "Current status: $status"
                case "$status" in
                    completed|failed|cancelled)
                        echo "Thread $thread_id finished: $status"
                        break
                        ;;
                    *)
                        sleep 5
                        ;;
                esac
            done
        fi
    fi
}

# ============================================================
# Commands: Templates
# ============================================================

cmd_templates() {
    local subcmd="${1:-list}"
    shift || true

    # Handle --help at templates level
    if is_help_flag "$subcmd"; then
        show_templates_help
        return 0
    fi

    case "$subcmd" in
        list|ls)
            cmd_templates_list "$@"
            ;;
        show)
            cmd_templates_show "$@"
            ;;
        "")
            cmd_templates_list "$@"
            ;;
        *)
            ct_suggest_command "$subcmd" "list" "show"
            ct_show_help_hint "ct templates"
            exit 1
            ;;
    esac
}

cmd_templates_list() {
    local template_dir="$DATA_DIR/templates"

    echo "Available Templates:"
    echo ""

    if [[ ! -d "$template_dir" ]]; then
        echo "  No templates directory found."
        echo ""
        echo "  Run 'ct init' to initialize with default templates."
        return 0
    fi

    # Find all .md files in templates directory
    local found=0
    while IFS= read -r -d '' template; do
        local relative_path="${template#$template_dir/}"
        local name="${relative_path%.md}"
        printf "  %-30s %s\n" "$relative_path" ""
        found=1
    done < <(find "$template_dir" -name "*.md" -type f -print0 2>/dev/null | sort -z)

    if [[ $found -eq 0 ]]; then
        echo "  No templates found in $template_dir"
        echo ""
        echo "  Create a template file (e.g., developer.md) with a prompt"
        echo "  for your thread to use."
    fi

    echo ""
    echo "Use a template:"
    echo "  ct spawn my-task --template <template-name>"
    echo "  ct thread create my-task --template <template-name>"
}

cmd_templates_show() {
    local name="$1"

    if [[ -z "$name" ]]; then
        ct_error_with_hint "Template name required" "ct templates show <template-name>"
        ct_show_help_hint "ct templates"
        exit 1
    fi

    local template_dir="$DATA_DIR/templates"
    local template_path="$template_dir/$name"

    # Try with and without .md extension
    if [[ ! -f "$template_path" ]]; then
        template_path="$template_dir/${name}.md"
    fi

    if [[ ! -f "$template_path" ]]; then
        ct_error_with_hint "Template not found: $name" "Run 'ct templates list' to see available templates"
        exit 1
    fi

    echo "Template: $name"
    echo "Path: $template_path"
    echo "========================================"
    echo ""
    cat "$template_path"
}

# ============================================================
# Commands: Config
# ============================================================

cmd_config() {
    local subcmd="${1:-show}"

    # Handle --help at config level
    if is_help_flag "$subcmd"; then
        show_config_help
        return 0
    fi

    case "$subcmd" in
        show)
            config_print
            ;;
        edit)
            ${EDITOR:-vi} "$DATA_DIR/config.yaml"
            ;;
        *)
            ct_suggest_command "$subcmd" "show" "edit"
            ct_show_help_hint "ct config"
            exit 1
            ;;
    esac
}

# ============================================================
# Commands: Version
# ============================================================

cmd_version() {
    echo "claude-threads v$VERSION"
}

# ============================================================
# Main
# ============================================================

main() {
    local command="${1:-}"
    shift || true

    # Initialize
    init_ct

    case "$command" in
        init)
            # Handle --help for init
            if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
                show_init_help
                return 0
            fi
            cmd_init "$@"
            ;;
        thread|t)
            cmd_thread "$@"
            ;;
        spawn)
            cmd_spawn "$@"
            ;;
        worktree|wt)
            cmd_worktree "$@"
            ;;
        orchestrator|orch|o)
            cmd_orchestrator "$@"
            ;;
        event|e)
            cmd_event "$@"
            ;;
        remote)
            cmd_remote "$@"
            ;;
        instances|inst|i)
            cmd_instances "$@"
            ;;
        templates|template)
            cmd_templates "$@"
            ;;
        migrate)
            # Handle --help for migrate
            if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
                show_migrate_help
                return 0
            fi
            cmd_migrate "$@"
            ;;
        webhook|wh)
            cmd_webhook "$@"
            ;;
        api)
            cmd_api "$@"
            ;;
        debug)
            cmd_debug "$@"
            ;;
        pr)
            cmd_pr "$@"
            ;;
        merge)
            cmd_merge "$@"
            ;;
        control)
            cmd_control "$@"
            ;;
        session|ses)
            cmd_session "$@"
            ;;
        memory|mem)
            cmd_memory "$@"
            ;;
        config|cfg)
            cmd_config "$@"
            ;;
        version|--version|-v)
            cmd_version
            ;;
        help)
            cmd_help "$@"
            ;;
        --help|-h|"")
            show_main_help
            ;;
        *)
            # Try to suggest similar commands
            local suggestions=()
            case "$command" in
                th*|thr*) suggestions+=("thread") ;;
                sp*) suggestions+=("spawn") ;;
                orch*) suggestions+=("orchestrator") ;;
                work*|wor*) suggestions+=("worktree") ;;
                rem*) suggestions+=("remote") ;;
                temp*) suggestions+=("templates") ;;
                ev*) suggestions+=("event") ;;
                web*) suggestions+=("webhook") ;;
                conf*) suggestions+=("config") ;;
                mig*) suggestions+=("migrate") ;;
                sess*|ses*) suggestions+=("session") ;;
                mem*) suggestions+=("memory") ;;
            esac

            if [[ ${#suggestions[@]} -gt 0 ]]; then
                ct_suggest_command "$command" "${suggestions[@]}"
            else
                echo "Unknown command: $command"
            fi
            ct_show_help_hint "ct"
            exit 1
            ;;
    esac
}

main "$@"
